<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Tyler Dash</title>
    <style>
      :root {
        color-scheme: dark;
        font-family: "Trebuchet MS", "Segoe UI", sans-serif;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        background: radial-gradient(circle at top, #1f2b3a 0%, #0b111a 60%, #05070b 100%);
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .game-shell {
        width: min(960px, 100%);
        aspect-ratio: 16 / 9;
        background: linear-gradient(180deg, rgba(16, 22, 32, 0.9) 0%, rgba(10, 14, 22, 0.95) 50%, rgba(8, 10, 16, 1) 100%);
        border: 2px solid rgba(255, 255, 255, 0.08);
        border-radius: 20px;
        overflow: hidden;
        position: relative;
        box-shadow: 0 30px 80px rgba(0, 0, 0, 0.45);
        touch-action: manipulation;
        --floor-bottom: 16px;
        --floor-height: 90px;
        --floor-top: calc(var(--floor-bottom) + var(--floor-height));
        --floor-grid: 24px;
        --floor-speed: 0.05s;
        --sky-horizon: calc(var(--floor-top) + 2px);
      }

      .game-shell,
      .game-shell * {
        user-select: none;
        -webkit-user-select: none;
        -webkit-touch-callout: none;
      }

      .hud {
        position: absolute;
        inset: 20px 24px auto;
        display: flex;
        flex-direction: column;
        gap: 8px;
        z-index: 3;
      }

      .scoreboard {
        position: absolute;
        top: 20px;
        right: 24px;
        display: flex;
        flex-direction: column;
        align-items: flex-end;
        gap: 4px;
        z-index: 3;
        pointer-events: none;
      }

      .score-label {
        font-size: 0.7rem;
        letter-spacing: 0.2em;
        text-transform: uppercase;
        color: rgba(255, 224, 138, 0.75);
      }

      .score-value {
        position: relative;
        font-size: clamp(1.6rem, 4vw, 2.6rem);
        font-weight: 700;
        letter-spacing: 0.12em;
        color: #ffd572;
        text-shadow: 0 0 12px rgba(255, 213, 114, 0.6);
        padding-right: 14px;
      }

      .score-value.is-updated .score-digits {
        animation: score-pop 0.4s ease, score-glow 2.4s ease-in-out infinite;
      }

      .score-digits {
        display: inline-block;
        animation: score-glow 2.4s ease-in-out infinite;
        text-shadow: 0 0 14px rgba(255, 213, 114, 0.75), 0 0 26px rgba(255, 213, 114, 0.45);
      }

      .score-value::before,
      .score-value::after {
        content: "";
        position: absolute;
        top: 50%;
        right: -4px;
        width: 12px;
        height: 12px;
        border-radius: 50%;
        background: radial-gradient(circle, rgba(255, 233, 173, 0.9), rgba(255, 233, 173, 0));
        transform: translateY(-50%) scale(0.6);
        opacity: 0.7;
        animation: sparkle 1.6s ease-in-out infinite;
      }

      .score-value::after {
        width: 18px;
        height: 18px;
        right: -16px;
        animation-delay: 0.4s;
        opacity: 0.5;
      }

      .score-sparkle {
        position: absolute;
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background: radial-gradient(circle, rgba(255, 233, 173, 0.85), rgba(255, 233, 173, 0));
        opacity: 0.6;
        animation: sparkle 1.8s ease-in-out infinite;
        pointer-events: none;
      }

      .score-sparkle.sparkle-one {
        top: -6px;
        right: 38px;
        animation-delay: 0.2s;
      }

      .score-sparkle.sparkle-two {
        top: 50%;
        right: 26px;
        transform: translateY(-50%);
        animation-delay: 0.7s;
      }

      .score-sparkle.sparkle-three {
        bottom: -8px;
        right: 12px;
        width: 14px;
        height: 14px;
        animation-delay: 1.1s;
      }

      .title {
        font-size: clamp(1.4rem, 3vw, 2.2rem);
        font-weight: 700;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: #d9f6ff;
      }

      .subtitle {
        font-size: clamp(0.85rem, 2vw, 1rem);
        color: rgba(217, 246, 255, 0.65);
      }

      .lane {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: flex-start;
        padding-left: clamp(24px, 6vw, 80px);
        z-index: 2;
      }

      .sky {
        position: absolute;
        inset: 0 0 var(--sky-horizon);
        background:
          linear-gradient(180deg, rgba(153, 227, 255, 0.72) 0%, rgba(129, 212, 255, 0.88) 42%, rgba(178, 232, 255, 0.95) 100%);
        overflow: hidden;
        z-index: 1;
      }

      .sky::before {
        content: "";
        position: absolute;
        inset: 0;
        background:
          repeating-linear-gradient(
            0deg,
            rgba(227, 245, 255, 0.16) 0 2px,
            transparent 2px 24px
          ),
          repeating-linear-gradient(
            90deg,
            rgba(227, 245, 255, 0.2) 0 2px,
            transparent 2px 24px
          );
        opacity: 0.75;
      }

      .swamp-transition {
        position: absolute;
        inset: 0;
        z-index: 5;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.2s ease;
      }

      .game-shell.is-transitioning .swamp-transition {
        opacity: 1;
      }

      .swamp-transition-sweep {
        position: absolute;
        inset: 0;
        width: 170%;
        transform: translateX(var(--transition-sweep-x, 100%));
        background:
          linear-gradient(
            90deg,
            rgba(0, 0, 0, 0) 0%,
            rgba(18, 45, 36, 0.18) 18%,
            rgba(27, 64, 50, 0.42) 34%,
            rgba(21, 49, 38, 0.66) 46%,
            rgba(31, 69, 53, 0.78) 56%,
            rgba(51, 94, 73, 0.84) 68%,
            rgba(73, 120, 93, 0.95) 84%,
            rgba(91, 137, 109, 1) 100%
          );
      }

      .transition-tree {
        position: absolute;
        width: clamp(120px, 16vw, 190px);
        height: clamp(190px, 34vh, 300px);
        left: 54%;
        bottom: calc(var(--floor-top) - 4px);
        transform: translateX(-50%);
        z-index: 2;
        filter: drop-shadow(0 8px 10px rgba(0, 0, 0, 0.55));
      }

      .transition-tree-trunk {
        position: absolute;
        left: 50%;
        bottom: 0;
        width: 24%;
        height: 63%;
        transform: translateX(-50%);
        background: rgba(9, 12, 11, 0.95);
        clip-path: polygon(37% 0, 64% 0, 74% 12%, 70% 30%, 76% 45%, 71% 59%, 74% 76%, 66% 100%, 36% 100%, 28% 74%, 32% 55%, 28% 40%, 32% 20%);
      }

      .transition-tree-branch {
        position: absolute;
        height: clamp(9px, 1.4vw, 15px);
        border-radius: 999px;
        background: rgba(9, 12, 11, 0.95);
        transform-origin: 0 50%;
      }

      .transition-tree-branch--left-main {
        width: 44%;
        top: 38%;
        left: 50%;
        transform: rotate(-152deg);
      }

      .transition-tree-branch--right-main {
        width: 39%;
        top: 43%;
        left: 53%;
        transform: rotate(-16deg);
      }

      .transition-tree-branch--top {
        width: 32%;
        top: 24%;
        left: 50%;
        transform: rotate(-94deg);
      }

      .transition-tree-branch--left-small {
        width: 23%;
        top: 30%;
        left: 45%;
        transform: rotate(-138deg);
      }

      .transition-tree-branch--right-small {
        width: 19%;
        top: 31%;
        left: 57%;
        transform: rotate(-35deg);
      }

      .swamp-tree-layer {
        position: absolute;
        inset: 0;
        pointer-events: none;
        opacity: 0;
        transition: opacity 1s ease;
      }

      .game-shell.area-swamp .swamp-tree-layer {
        opacity: 1;
      }

      .swamp-tree {
        position: absolute;
        bottom: calc(var(--floor-top) - 8px);
        width: var(--tree-size, 120px);
        height: calc(var(--tree-size, 120px) * 1.55);
        opacity: var(--tree-opacity, 0.2);
        transform: translateX(-50%);
        filter: blur(0.4px);
      }

      .swamp-tree .transition-tree-trunk,
      .swamp-tree .transition-tree-branch {
        background: rgba(10, 20, 16, 0.85);
      }

      .cloud-layer {
        position: absolute;
        inset: 0;
        pointer-events: none;
      }

      .cloud {
        position: absolute;
        display: grid;
        grid-auto-flow: column;
        gap: 0;
        will-change: transform;
        filter: drop-shadow(0 6px 8px rgba(54, 120, 160, 0.34));
      }

      .cloud-cube {
        width: 10px;
        height: 10px;
        margin: -1px;
        border-radius: 50%;
        background: radial-gradient(circle at 35% 30%, #ffffff 0 34%, #e7f6ff 68%, #c2deef 100%);
        box-shadow: 0 0 0 1px rgba(216, 238, 252, 0.9), 0 1px 2px rgba(88, 143, 173, 0.42);
      }

      .grass-field {
        position: absolute;
        left: 0;
        right: 0;
        bottom: var(--floor-top);
        height: clamp(26px, 4.6vw, 38px);
        pointer-events: none;
        overflow: hidden;
        z-index: 3;
      }

      .grass-blade {
        position: absolute;
        bottom: 0;
        width: 12px;
        height: 34px;
        clip-path: polygon(50% 0%, 0% 100%, 100% 100%);
        transform-origin: 50% 100%;
        filter: drop-shadow(0 6px 5px rgba(24, 99, 44, 0.3));
        will-change: transform;
        opacity: 0.95;
      }

      .grass-blade--faded {
        height: 26px;
        width: 10px;
        opacity: 0.88;
        background: linear-gradient(180deg, #8ac08e 0%, #5f9f67 100%);
      }

      .grass-blade--bright {
        height: 36px;
        width: 12px;
        background: linear-gradient(180deg, #8fff7a 0%, #4ecb4e 55%, #26912d 100%);
      }

      .grass-blade.is-swaying {
        animation: grass-sway-back 0.9s cubic-bezier(0.35, 0.12, 0.2, 1);
      }

      .square {
        width: clamp(48px, 7vw, 72px);
        height: clamp(48px, 7vw, 72px);
        background:
          repeating-linear-gradient(0deg, rgba(255, 226, 143, 0.95) 0 6px, rgba(246, 204, 102, 0.95) 6px 12px),
          repeating-linear-gradient(90deg, rgba(205, 155, 68, 0.35) 0 2px, rgba(255, 233, 170, 0.28) 2px 10px),
          linear-gradient(145deg, #fff1bf 0%, #f4c96f 54%, #c48a32 100%);
        image-rendering: pixelated;
        border-radius: 2px;
        border: 3px solid #7a5320;
        box-shadow: 0 0 0 2px #ffe09d, 0 18px 30px rgba(78, 53, 21, 0.42);
        position: absolute;
        left: clamp(24px, 6vw, 80px);
        bottom: var(--floor-top);
        transform: translateY(0);
        transform-origin: center;
        overflow: hidden;
      }

      .square.is-swamp {
        background:
          repeating-linear-gradient(0deg, rgba(165, 236, 149, 0.98) 0 6px, rgba(127, 204, 108, 0.98) 6px 12px),
          repeating-linear-gradient(90deg, rgba(56, 118, 63, 0.42) 0 2px, rgba(175, 236, 160, 0.28) 2px 10px),
          linear-gradient(145deg, #c5f6b6 0%, #95da79 55%, #4f8f52 100%);
        border-color: #376d3f;
        box-shadow: 0 0 0 2px #c4f7bb, 0 18px 30px rgba(33, 87, 41, 0.42);
      }

      .square-face {
        position: absolute;
        inset: 0;
        pointer-events: none;
      }

      .square-eye {
        position: absolute;
        width: clamp(4px, 0.8vw, 7px);
        height: clamp(4px, 0.8vw, 7px);
        background: #4b2d0d;
        border: 1px solid rgba(255, 240, 207, 0.42);
      }

      .square-eye--left {
        left: 30%;
        top: 42%;
      }

      .square-eye--right {
        left: 56%;
        top: 33%;
      }

      .square-mouth {
        position: absolute;
        left: 34%;
        top: 58%;
        width: 34%;
        height: clamp(5px, 1vw, 8px);
        background: #77421b;
        border: 1px solid rgba(255, 235, 184, 0.45);
      }

      .square.is-swamp .square-eye {
        background: #b7ffd3;
        border-color: rgba(215, 255, 222, 0.95);
        box-shadow: 0 0 8px rgba(144, 255, 188, 0.9), 0 0 18px rgba(126, 255, 181, 0.8);
        animation: swamp-glow 1.25s ease-in-out infinite alternate;
      }

      .square.is-swamp .square-mouth {
        background: #c5ffd9;
        border-color: rgba(215, 255, 222, 0.95);
        box-shadow: 0 0 8px rgba(132, 255, 182, 0.9), 0 0 18px rgba(126, 255, 181, 0.8);
        animation: swamp-glow 1.4s ease-in-out infinite alternate;
      }

      .square-vines {
        position: absolute;
        inset: -8px;
        opacity: 0;
        transition: opacity 0.16s ease;
        pointer-events: none;
      }

      .square.is-swamp .square-vines {
        opacity: 1;
      }

      .vine {
        position: absolute;
        width: 11px;
        height: 24px;
        border-radius: 999px;
        background: linear-gradient(180deg, #3f8f4a 0%, #23572b 100%);
        box-shadow: 0 0 0 1px rgba(190, 245, 182, 0.35);
      }

      .vine::after {
        content: "";
        position: absolute;
        width: 8px;
        height: 8px;
        border-radius: 50% 50% 45% 45%;
        background: linear-gradient(145deg, #8fd68d 0%, #3f8f4a 80%);
        top: 26%;
        left: 72%;
        transform: rotate(24deg);
      }

      .vine--top {
        height: 26px;
        left: 26%;
        top: -6px;
        transform: rotate(-20deg);
      }

      .vine--right {
        height: 30px;
        right: -6px;
        top: 42%;
        transform: rotate(28deg);
      }

      .vine--left {
        height: 23px;
        left: -8px;
        top: 55%;
        transform: rotate(-34deg);
      }

      .vine--top-right {
        height: 28px;
        top: -8px;
        left: 56%;
        transform: rotate(22deg);
      }

      .vine--top-left {
        height: 20px;
        top: -8px;
        left: 8%;
        transform: rotate(-38deg);
      }

      .vine--mid-right {
        height: 22px;
        right: 4px;
        top: 20%;
        transform: rotate(42deg);
      }

      .vine--mid-left {
        height: 25px;
        left: 2px;
        top: 26%;
        transform: rotate(-40deg);
      }

      .vine--bottom {
        height: 22px;
        left: 46%;
        bottom: -8px;
        transform: rotate(12deg);
      }

      .vine--bottom-left {
        height: 19px;
        left: 18%;
        bottom: -7px;
        transform: rotate(-20deg);
      }

      .vine--bottom-right {
        height: 24px;
        right: 14%;
        bottom: -8px;
        transform: rotate(30deg);
      }

      .cube {
        position: absolute;
        bottom: var(--floor-top);
        z-index: 2;
        width: clamp(46px, 6.8vw, 70px);
        height: clamp(46px, 6.8vw, 70px);
        background:
          repeating-linear-gradient(0deg, #f5da84 0 7px, #ddb65a 7px 14px),
          repeating-linear-gradient(90deg, #8b6333 0 3px, #d9b35a 3px 14px),
          linear-gradient(145deg, #ffefb6 0%, #ebc56d 50%, #a9783d 100%);
        image-rendering: pixelated;
        border: 3px solid #6a4721;
        border-radius: 1px;
        box-shadow: 0 12px 0 #7d5627, 0 0 0 3px #ffe5ab, 0 0 22px rgba(188, 136, 56, 0.58);
      }

      .spike {
        position: absolute;
        bottom: var(--floor-top);
        z-index: 2;
        width: clamp(46px, 6.5vw, 70px);
        height: clamp(34px, 4.8vw, 48px);
        background:
          repeating-linear-gradient(112deg, #fde29a 0 6px, #f6cf70 6px 11px, #e9b853 11px 16px),
          linear-gradient(180deg, #ffe9a9 0%, #f4ce72 58%, #d7a64b 100%);
        border: 3px solid #3f2f20;
        border-radius: 7px 7px 4px 4px;
        box-shadow: 0 10px 12px rgba(46, 37, 24, 0.58), 0 0 0 3px #e8cf91;
        overflow: visible;
      }

      .spike::before {
        content: "";
        position: absolute;
        width: 16%;
        height: 136%;
        left: 50%;
        bottom: 40%;
        translate: -50% 0;
        transform: rotate(-26deg);
        transform-origin: 50% 100%;
        background:
          linear-gradient(180deg, #b57a3f 0%, #7b4f26 54%, #633d1e 100%);
        border-radius: 8px;
        box-shadow: inset 0 0 0 1px rgba(255, 223, 163, 0.32);
      }

      .spike::after {
        content: "";
        position: absolute;
        width: 116%;
        height: 136%;
        left: 50%;
        bottom: 40%;
        translate: -50% 0;
        transform: rotate(-26deg);
        transform-origin: 50% 100%;
        background:
          linear-gradient(180deg, #d4e2f2 0%, #9fb5cb 100%),
          linear-gradient(180deg, #d4e2f2 0%, #9fb5cb 100%),
          linear-gradient(180deg, #d4e2f2 0%, #9fb5cb 100%),
          linear-gradient(180deg, #ccb179 0%, #a78146 100%);
        background-size: 8% 27%, 8% 20%, 8% 27%, 74% 12%;
        background-position: 72% 14%, 72% 23%, 72% 32%, 50% 29%;
        background-repeat: no-repeat;
        border-radius: 8px;
        pointer-events: none;
      }

      .game-message {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: clamp(1.8rem, 4vw, 3rem);
        font-weight: 700;
        letter-spacing: 0.12em;
        text-transform: uppercase;
        color: #ff9fb0;
        background: rgba(5, 7, 11, 0.65);
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.2s ease;
        z-index: 4;
        flex-direction: column;
        gap: 16px;
      }

      .game-message.is-visible {
        opacity: 1;
        pointer-events: auto;
      }

      .retry-button {
        border: none;
        border-radius: 999px;
        padding: 12px 26px;
        font-size: 0.95rem;
        letter-spacing: 0.12em;
        text-transform: uppercase;
        font-weight: 700;
        color: #07101b;
        background: linear-gradient(135deg, #ffd86f 0%, #ffb347 60%, #ff9b55 100%);
        box-shadow: 0 14px 24px rgba(255, 184, 91, 0.35);
        cursor: pointer;
      }

      .retry-button:focus-visible {
        outline: 3px solid rgba(255, 216, 111, 0.6);
        outline-offset: 4px;
      }

      .floor {
        position: absolute;
        left: 0;
        right: 0;
        bottom: var(--floor-bottom);
        height: var(--floor-height);
        background:
          repeating-linear-gradient(
            90deg,
            rgba(73, 51, 30, 0.45) 0 2px,
            transparent 2px 32px
          ),
          repeating-linear-gradient(
            0deg,
            rgba(73, 51, 30, 0.35) 0 2px,
            transparent 2px 32px
          ),
          linear-gradient(180deg, #8f6438 0%, #724d2d 52%, #593a22 100%);
        background-size: var(--floor-grid) var(--floor-grid), var(--floor-grid) var(--floor-grid), 100% 100%;
        background-position: 0 0, 0 0, 0 0;
        animation: floor-slide var(--floor-speed) linear infinite;
        border-top: 2px solid rgba(217, 165, 104, 0.9);
      }

      .floor::before {
        content: "";
        position: absolute;
        inset: 14px 0 12px;
        background: repeating-linear-gradient(
          90deg,
          rgba(185, 130, 72, 0.32) 0 18px,
          rgba(101, 68, 38, 0.28) 18px 32px
        );
        opacity: 0.82;
        pointer-events: none;
      }

      .game-shell.is-paused .floor {
        animation-play-state: paused;
      }

      .sky {
        transition: background 1.15s ease;
      }

      .game-shell.area-swamp .sky {
        background:
          linear-gradient(180deg, rgba(111, 150, 126, 0.72) 0%, rgba(87, 126, 105, 0.9) 42%, rgba(74, 112, 92, 0.97) 100%);
      }

      .floor::after {
        content: "";
        position: absolute;
        inset: -12px 0 auto;
        height: 12px;
        background: linear-gradient(90deg, rgba(180, 124, 72, 0.68), rgba(180, 124, 72, 0));
      }

      .floor-shadow {
        position: absolute;
        left: 0;
        right: 0;
        bottom: var(--floor-bottom);
        height: 20px;
        background: radial-gradient(circle at 30% 0%, rgba(141, 95, 57, 0.48), transparent 70%);
        opacity: 0.5;
        filter: blur(6px);
      }

      .ground-plane {
        position: absolute;
        left: 0;
        right: 0;
        bottom: 0;
        height: 120px;
        background: linear-gradient(180deg, rgba(37, 23, 14, 0) 0%, rgba(58, 40, 24, 0.72) 62%, rgba(45, 30, 18, 1) 100%);
      }

      .touch-hint {
        position: absolute;
        bottom: 18px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 0.9rem;
        color: rgba(217, 246, 255, 0.6);
        text-align: center;
        z-index: 2;
        padding: 8px 16px;
        border-radius: 999px;
        background: rgba(6, 12, 20, 0.7);
        border: 1px solid rgba(255, 255, 255, 0.08);
      }

      @keyframes floor-slide {
        0% {
          background-position: 0 0, 0 0, 0 0;
        }
        100% {
          background-position: calc(-1 * var(--floor-grid)) 0, calc(-1 * var(--floor-grid)) 0, 0 0;
        }
      }

      @keyframes swamp-glow {
        from {
          filter: brightness(1);
        }
        to {
          filter: brightness(1.2);
        }
      }

      @keyframes sparkle {
        0%,
        100% {
          transform: translateY(-50%) scale(0.6);
          opacity: 0.4;
        }
        50% {
          transform: translateY(-60%) scale(1);
          opacity: 0.9;
        }
      }

      @keyframes score-pop {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.12);
        }
        100% {
          transform: scale(1);
        }
      }

      @keyframes score-glow {
        0%,
        100% {
          text-shadow: 0 0 10px rgba(255, 213, 114, 0.6), 0 0 18px rgba(255, 213, 114, 0.35);
        }
        50% {
          text-shadow: 0 0 16px rgba(255, 213, 114, 0.9), 0 0 32px rgba(255, 213, 114, 0.55);
        }
      }

      @keyframes grass-sway-back {
        0% {
          transform: rotate(0deg) translateY(0);
        }
        40% {
          transform: rotate(-22deg) translateY(1px);
        }
        100% {
          transform: rotate(0deg) translateY(0);
        }
      }

      @media (max-width: 600px) {
        .game-shell {
          border-radius: 0;
          height: 100vh;
          width: 100%;
          aspect-ratio: auto;
        }

        .touch-hint {
          bottom: 12px;
          font-size: 0.8rem;
        }
      }
    </style>
  </head>
  <body>
    <main class="game-shell" id="game">
      <div class="hud">
        <div class="title">Tyler Dash</div>
        <div class="subtitle">Tap to hop. Press & hold to chain jumps • build platform-top-landing</div>
      </div>
      <div class="scoreboard">
        <div class="score-label">Score</div>
        <div class="score-value" id="scoreValue">
          <span class="score-digits">0</span>
          <span class="score-sparkle sparkle-one" aria-hidden="true"></span>
          <span class="score-sparkle sparkle-two" aria-hidden="true"></span>
          <span class="score-sparkle sparkle-three" aria-hidden="true"></span>
        </div>
      </div>
      <div class="sky" aria-hidden="true">
        <div class="swamp-tree-layer" aria-hidden="true">
          <div class="swamp-tree" style="left: 18%; --tree-size: 84px; --tree-opacity: 0.12;">
            <span class="transition-tree-trunk"></span>
            <span class="transition-tree-branch transition-tree-branch--left-main"></span>
            <span class="transition-tree-branch transition-tree-branch--right-main"></span>
            <span class="transition-tree-branch transition-tree-branch--top"></span>
            <span class="transition-tree-branch transition-tree-branch--left-small"></span>
            <span class="transition-tree-branch transition-tree-branch--right-small"></span>
          </div>
          <div class="swamp-tree" style="left: 36%; --tree-size: 112px; --tree-opacity: 0.2;">
            <span class="transition-tree-trunk"></span>
            <span class="transition-tree-branch transition-tree-branch--left-main"></span>
            <span class="transition-tree-branch transition-tree-branch--right-main"></span>
            <span class="transition-tree-branch transition-tree-branch--top"></span>
            <span class="transition-tree-branch transition-tree-branch--left-small"></span>
            <span class="transition-tree-branch transition-tree-branch--right-small"></span>
          </div>
          <div class="swamp-tree" style="left: 54%; --tree-size: 74px; --tree-opacity: 0.1;">
            <span class="transition-tree-trunk"></span>
            <span class="transition-tree-branch transition-tree-branch--left-main"></span>
            <span class="transition-tree-branch transition-tree-branch--right-main"></span>
            <span class="transition-tree-branch transition-tree-branch--top"></span>
            <span class="transition-tree-branch transition-tree-branch--left-small"></span>
            <span class="transition-tree-branch transition-tree-branch--right-small"></span>
          </div>
          <div class="swamp-tree" style="left: 68%; --tree-size: 136px; --tree-opacity: 0.23;">
            <span class="transition-tree-trunk"></span>
            <span class="transition-tree-branch transition-tree-branch--left-main"></span>
            <span class="transition-tree-branch transition-tree-branch--right-main"></span>
            <span class="transition-tree-branch transition-tree-branch--top"></span>
            <span class="transition-tree-branch transition-tree-branch--left-small"></span>
            <span class="transition-tree-branch transition-tree-branch--right-small"></span>
          </div>
          <div class="swamp-tree" style="left: 82%; --tree-size: 94px; --tree-opacity: 0.15;">
            <span class="transition-tree-trunk"></span>
            <span class="transition-tree-branch transition-tree-branch--left-main"></span>
            <span class="transition-tree-branch transition-tree-branch--right-main"></span>
            <span class="transition-tree-branch transition-tree-branch--top"></span>
            <span class="transition-tree-branch transition-tree-branch--left-small"></span>
            <span class="transition-tree-branch transition-tree-branch--right-small"></span>
          </div>
        </div>
        <div class="cloud-layer" id="cloudLayer"></div>
      </div>
      <div class="swamp-transition" id="swampTransition" aria-hidden="true">
        <div class="swamp-transition-sweep">
          <div class="transition-tree" aria-hidden="true">
            <span class="transition-tree-trunk"></span>
            <span class="transition-tree-branch transition-tree-branch--left-main"></span>
            <span class="transition-tree-branch transition-tree-branch--right-main"></span>
            <span class="transition-tree-branch transition-tree-branch--top"></span>
            <span class="transition-tree-branch transition-tree-branch--left-small"></span>
            <span class="transition-tree-branch transition-tree-branch--right-small"></span>
          </div>
        </div>
      </div>
      <div class="lane">
        <div class="square" id="square">
          <div class="square-face" aria-hidden="true">
            <span class="square-eye square-eye--left"></span>
            <span class="square-eye square-eye--right"></span>
            <span class="square-mouth"></span>
          </div>
          <div class="square-vines" aria-hidden="true">
            <span class="vine vine--top"></span>
            <span class="vine vine--right"></span>
            <span class="vine vine--left"></span>
            <span class="vine vine--top-right"></span>
            <span class="vine vine--top-left"></span>
            <span class="vine vine--mid-right"></span>
            <span class="vine vine--mid-left"></span>
            <span class="vine vine--bottom"></span>
            <span class="vine vine--bottom-left"></span>
            <span class="vine vine--bottom-right"></span>
          </div>
        </div>
      </div>
      <div class="grass-field" id="grassField" aria-hidden="true"></div>
      <div class="game-message" id="gameMessage">
        <div>Game Over</div>
        <button class="retry-button" id="retryButton" type="button">Retry</button>
      </div>
      <div class="floor-shadow"></div>
      <div class="floor"></div>
      <div class="ground-plane"></div>
      <div class="touch-hint">Tap to hop • Press &amp; hold to chain jumps</div>
    </main>

    <script>
      const square = document.getElementById("square");
      const game = document.getElementById("game");
      const gameMessage = document.getElementById("gameMessage");
      const scoreValue = document.getElementById("scoreValue");
      const retryButton = document.getElementById("retryButton");
      const grassField = document.getElementById("grassField");
      const cloudLayer = document.getElementById("cloudLayer");

      const state = {
        y: 0,
        velocity: 0,
        isJumping: false,
        isHolding: false,
        rotation: 0,
        rotationStart: 0,
        rotationTarget: 0,
        rotationFrames: 0,
        airFrame: 0,
        prevY: 0,
        isGameOver: false,
        onPlatform: false,
        platform: null,
        fallingFrom: null,
        score: 0,
        area: "meadow",
        transitionProgress: 0,
      };

      const gravity = -0.9;
      const jumpVelocity = 16.05;
      const totalAirFrames = Math.ceil((2 * jumpVelocity) / -gravity);
      const obstacleIntervalMs = 3000;
      const obstacleSpeed = 480;
      const obstaclePadding = 24;
      const obstacles = [];
      const obstacleTypes = ["spike", "cube"];
      const grassBlades = [];
      const grassSpawnPadding = 20;
      const grassSpeed = obstacleSpeed * 0.72;
      const grassSpawnIntervalMs = 180;
      const grassSwayIntervalMs = 2400;
      const clouds = [];
      const cloudSpeed = obstacleSpeed * 0.34;
      const cloudSpawnIntervalMs = 1650;
      const cloudSpawnPadding = 120;
      const swampScoreThreshold = 15;
      const swampTransitionDurationMs = 4600;
      const transitionSweepTravel = 180;
      const transitionBlackStart = 0.42;
      const transitionBlackEnd = 0.66;
      const transitionOverlayWidthRatio = 1.7;
      const squareBackEdgeX = () => {
        const squareRect = square.getBoundingClientRect();
        return squareRect.left + squareRect.width * 0.5;
      };

      let lastFrameTime = 0;
      let obstacleTimer = 0;
      let grassSpawnTimer = 0;
      let grassSwayTimer = 0;
      let cloudSpawnTimer = 0;

      const spawnObstacle = () => {
        const obstacle = document.createElement("div");
        const type = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
        obstacle.className = type;
        obstacle.dataset.type = type;
        const startX = game.clientWidth + obstaclePadding;
        obstacle.dataset.x = startX.toString();
        obstacle.style.transform = `translateX(${startX}px)`;
        game.appendChild(obstacle);
        obstacles.push(obstacle);
      };

      const updateScore = () => {
        const digits = scoreValue.querySelector(".score-digits");
        if (digits) {
          digits.textContent = state.score.toString();
        }
        scoreValue.classList.add("is-updated");
        window.setTimeout(() => {
          scoreValue.classList.remove("is-updated");
        }, 350);
      };

      const resetGame = () => {
        state.y = 0;
        state.velocity = 0;
        state.isJumping = false;
        state.isHolding = false;
        state.rotation = 0;
        state.rotationStart = 0;
        state.rotationTarget = 0;
        state.rotationFrames = totalAirFrames;
        state.airFrame = 0;
        state.prevY = 0;
        state.isGameOver = false;
        state.onPlatform = false;
        state.platform = null;
        state.fallingFrom = null;
        state.score = 0;
        state.area = "meadow";
        state.transitionProgress = 0;
        obstacleTimer = 0;
        grassSpawnTimer = 0;
        grassSwayTimer = 0;
        cloudSpawnTimer = 0;
        obstacles.splice(0).forEach((obstacle) => obstacle.remove());
        grassBlades.splice(0).forEach((blade) => blade.element.remove());
        clouds.splice(0).forEach((cloud) => cloud.element.remove());
        gameMessage.classList.remove("is-visible");
        game.classList.remove("is-paused");
        game.classList.remove("is-transitioning", "area-swamp");
        square.classList.remove("is-swamp");
        game.style.setProperty("--transition-sweep-x", "100%");
        updateScore();
      };

      const beginSwampTransition = () => {
        if (state.area !== "meadow") {
          return;
        }
        state.area = "transition";
        state.transitionProgress = 0;
        game.classList.add("is-transitioning");
      };

      const updateSwampTransition = (delta, squareRect) => {
        if (state.area !== "transition") {
          return;
        }

        state.transitionProgress = Math.min(state.transitionProgress + (delta * 1000) / swampTransitionDurationMs, 1);
        const sweepX = 100 - transitionSweepTravel * state.transitionProgress;
        game.style.setProperty("--transition-sweep-x", `${sweepX}%`);

        const gameRect = game.getBoundingClientRect();
        const overlayWidth = gameRect.width * transitionOverlayWidthRatio;
        const overlayLeft = gameRect.left + (sweepX / 100) * overlayWidth;
        const blackLeft = overlayLeft + overlayWidth * transitionBlackStart;
        const blackRight = overlayLeft + overlayWidth * transitionBlackEnd;
        const squareCenter = squareRect.left + squareRect.width * 0.5;

        if (squareCenter >= blackLeft && squareCenter <= blackRight) {
          square.classList.add("is-swamp");
        }

        if (state.transitionProgress >= 1) {
          state.area = "swamp";
          game.classList.remove("is-transitioning");
          game.classList.add("area-swamp");
          square.classList.add("is-swamp");
        }
      };

      const createCloudShape = () => {
        const rows = 5 + Math.floor(Math.random() * 3);
        const cols = 11 + Math.floor(Math.random() * 6);
        const centerRow = (rows - 1) / 2;
        const centerCol = (cols - 1) / 2;
        const blobCount = 3 + Math.floor(Math.random() * 3);
        const blobs = Array.from({ length: blobCount }, (_, index) => ({
          row: centerRow + (Math.random() - 0.5) * (index === 0 ? 0.8 : 2.2),
          col: centerCol + (Math.random() - 0.5) * (index === 0 ? 1.6 : 5.2),
          radius: 1.8 + Math.random() * 1.7,
        }));
        const occupied = new Set();

        for (let row = 0; row < rows; row += 1) {
          for (let col = 0; col < cols; col += 1) {
            const isInsideBlob = blobs.some((blob) => {
              const rowDelta = row - blob.row;
              const colDelta = (col - blob.col) * 0.92;
              return Math.sqrt(rowDelta * rowDelta + colDelta * colDelta) <= blob.radius;
            });

            if (isInsideBlob) {
              occupied.add(`${row},${col}`);
            }
          }
        }

        const connected = new Set();
        const start = `${Math.round(centerRow)},${Math.round(centerCol)}`;
        if (occupied.has(start)) {
          const stack = [start];
          while (stack.length) {
            const current = stack.pop();
            if (!current || connected.has(current)) {
              continue;
            }
            connected.add(current);
            const [row, col] = current.split(",").map(Number);
            [
              [row - 1, col],
              [row + 1, col],
              [row, col - 1],
              [row, col + 1],
            ].forEach(([nextRow, nextCol]) => {
              const key = `${nextRow},${nextCol}`;
              if (occupied.has(key) && !connected.has(key)) {
                stack.push(key);
              }
            });
          }
        }

        const cloudShape = [...connected].map((cell) => {
          const [row, col] = cell.split(",").map(Number);
          return { row, col };
        });

        return cloudShape.length ? cloudShape : [{ row: Math.round(centerRow), col: Math.round(centerCol) }];
      };

      const spawnCloud = () => {
        if (!cloudLayer) {
          return;
        }
        const cloud = document.createElement("div");
        cloud.className = "cloud";
        const cubeMap = createCloudShape();
        const cubeSize = 10;
        const maxCol = Math.max(...cubeMap.map((cube) => cube.col), 0);
        const maxRow = Math.max(...cubeMap.map((cube) => cube.row), 0);
        cloud.style.width = `${(maxCol + 1) * (cubeSize + 2)}px`;
        cloud.style.height = `${(maxRow + 1) * (cubeSize + 2)}px`;
        cubeMap.forEach((cube) => {
          const cubeElement = document.createElement("span");
          cubeElement.className = "cloud-cube";
          cubeElement.style.gridColumn = `${cube.col + 1}`;
          cubeElement.style.gridRow = `${cube.row + 1}`;
          cloud.appendChild(cubeElement);
        });

        const startX = game.clientWidth + cloudSpawnPadding;
        const y = 26 + Math.random() * 136;
        cloud.style.transform = `translate(${startX}px, ${y}px)`;
        cloudLayer.appendChild(cloud);
        clouds.push({ element: cloud, x: startX, y });
      };

      const spawnGrassBlade = () => {
        if (!grassField) {
          return;
        }
        const blade = document.createElement("div");
        const isFaded = Math.random() < 0.42;
        blade.className = `grass-blade ${isFaded ? "grass-blade--faded" : "grass-blade--bright"}`;
        const startX = game.clientWidth + grassSpawnPadding + Math.random() * 70;
        const verticalOffset = Math.random() < 0.35 ? Math.random() * 8 : 0;
        blade.style.transform = `translateY(${verticalOffset}px)`;
        blade.style.left = `${startX}px`;
        grassField.appendChild(blade);
        grassBlades.push({ element: blade, x: startX, hasPassedSquare: false, isFaded });
      };

      const swayPassedGrass = () => {
        const passed = grassBlades.filter((blade) => blade.hasPassedSquare);
        if (!passed.length) {
          return;
        }
        const swayCount = Math.min(passed.length, Math.random() < 0.5 ? 2 : 3);
        for (let i = passed.length - 1; i > 0; i -= 1) {
          const swapIndex = Math.floor(Math.random() * (i + 1));
          [passed[i], passed[swapIndex]] = [passed[swapIndex], passed[i]];
        }
        passed.slice(0, swayCount).forEach((blade) => {
          blade.element.classList.remove("is-swaying");
          void blade.element.offsetWidth;
          blade.element.classList.add("is-swaying");
        });
      };

      const triggerGameOver = () => {
        if (state.isGameOver) {
          return;
        }
        state.isGameOver = true;
        state.isJumping = false;
        state.isHolding = false;
        state.velocity = 0;
        state.rotationStart = state.rotation;
        state.rotationTarget = state.rotation;
        state.rotationFrames = totalAirFrames;
        gameMessage.classList.add("is-visible");
        game.classList.add("is-paused");
      };

      const checkCollision = (cubeRect, obstacleRect) => {
        const obstacleInset = Math.min(obstacleRect.width, obstacleRect.height) * 0.16;
        const cubeInset = Math.min(cubeRect.width, cubeRect.height) * 0.08;
        return !(
          cubeRect.right - cubeInset < obstacleRect.left + obstacleInset ||
          cubeRect.left + cubeInset > obstacleRect.right - obstacleInset ||
          cubeRect.bottom - cubeInset < obstacleRect.top + obstacleInset ||
          cubeRect.top + cubeInset > obstacleRect.bottom - obstacleInset
        );
      };

      const getSquareHitbox = (yOverride = state.y) => {
        const gameRect = game.getBoundingClientRect();
        const squareStyle = window.getComputedStyle(square);
        const left = gameRect.left + Number.parseFloat(squareStyle.left || "0");
        const bottom = gameRect.bottom - Number.parseFloat(squareStyle.bottom || "0") - yOverride;
        const width = square.offsetWidth;
        const height = square.offsetHeight;
        return {
          left,
          right: left + width,
          top: bottom - height,
          bottom,
          width,
          height,
        };
      };

      const calculateFallFrames = (height) => {
        const gravityMagnitude = Math.abs(gravity);
        if (height <= 0) {
          return 1;
        }
        const frames = Math.ceil((Math.sqrt(1 + (8 * height) / gravityMagnitude) - 1) / 2);
        return Math.max(frames, 1);
      };

      const update = (time) => {
        if (!lastFrameTime) {
          lastFrameTime = time;
        }
        const delta = Math.min((time - lastFrameTime) / 1000, 0.05);
        lastFrameTime = time;
        state.prevY = state.y;

        if (state.isJumping) {
          state.velocity += gravity;
          state.y += state.velocity;
          state.airFrame += 1;
          const progress = Math.min(state.airFrame / state.rotationFrames, 1);
          state.rotation = state.rotationStart + (state.rotationTarget - state.rotationStart) * progress;

          if (state.y <= 0) {
            state.y = 0;
            state.velocity = 0;
            state.isJumping = false;
            state.rotation = state.rotationTarget % 360;
            state.airFrame = 0;
            state.rotationFrames = totalAirFrames;
            state.onPlatform = false;
            state.platform = null;
            state.fallingFrom = null;
            if (state.isHolding) {
              jump();
            }
          }
        }

        square.style.transform = `translateY(${-state.y}px) rotate(${state.rotation}deg)`;
        if (!state.isGameOver) {
          obstacleTimer += delta * 1000;
          grassSpawnTimer += delta * 1000;
          grassSwayTimer += delta * 1000;
          cloudSpawnTimer += delta * 1000;

          if (grassSpawnTimer >= grassSpawnIntervalMs) {
            grassSpawnTimer = 0;
            spawnGrassBlade();
            if (Math.random() < 0.55) {
              spawnGrassBlade();
            }
          }

          const squarePassX = squareBackEdgeX();
          for (let i = grassBlades.length - 1; i >= 0; i -= 1) {
            const blade = grassBlades[i];
            blade.x -= grassSpeed * delta;
            blade.element.style.left = `${blade.x}px`;

            const bladeRect = blade.element.getBoundingClientRect();
            if (!blade.hasPassedSquare && bladeRect.right < squarePassX) {
              blade.hasPassedSquare = true;
            }

            if (blade.x < -grassSpawnPadding * 2) {
              blade.element.remove();
              grassBlades.splice(i, 1);
            }
          }

          if (grassSwayTimer >= grassSwayIntervalMs) {
            grassSwayTimer = 0;
            swayPassedGrass();
          }

          if (cloudSpawnTimer >= cloudSpawnIntervalMs) {
            cloudSpawnTimer = 0;
            spawnCloud();
          }

          for (let i = clouds.length - 1; i >= 0; i -= 1) {
            const cloud = clouds[i];
            cloud.x -= cloudSpeed * delta;
            cloud.element.style.transform = `translate(${cloud.x}px, ${cloud.y}px)`;

            if (cloud.x < -cloudSpawnPadding * 2.5) {
              cloud.element.remove();
              clouds.splice(i, 1);
            }
          }

          if (obstacleTimer >= obstacleIntervalMs) {
            obstacleTimer = 0;
            spawnObstacle();
          }

          const squareRect = getSquareHitbox(state.y);
          const prevSquareRect = getSquareHitbox(state.prevY);
          let platformStillUnder = false;
          for (let i = obstacles.length - 1; i >= 0; i -= 1) {
            const obstacle = obstacles[i];
            const currentX = Number(obstacle.dataset.x || 0);
            const nextX = currentX - obstacleSpeed * delta;
            obstacle.dataset.x = nextX.toString();
            obstacle.style.transform = `translateX(${nextX}px)`;

            if (nextX < -obstaclePadding * 2) {
              obstacle.remove();
              obstacles.splice(i, 1);
              continue;
            }

            const obstacleRect = obstacle.getBoundingClientRect();
            if (!state.isGameOver && !obstacle.dataset.scored && obstacleRect.right < squareRect.left) {
              if (state.y > 0) {
                state.score += 1;
                updateScore();
                if (state.score >= swampScoreThreshold) {
                  beginSwampTransition();
                }
              }
              obstacle.dataset.scored = "true";
            }
            if (obstacle.dataset.type === "cube") {
              if (state.fallingFrom === obstacle) {
                continue;
              }
              const horizontalOverlap = Math.min(squareRect.right, obstacleRect.right) - Math.max(squareRect.left, obstacleRect.left);
              const minOverlap = Math.max(10, squareRect.width * 0.25);
              const eps = 2;
              const landedFromAbove =
                state.velocity <= 0 &&
                checkCollision(squareRect, obstacleRect) &&
                prevSquareRect.bottom <= obstacleRect.top + eps &&
                squareRect.bottom >= obstacleRect.top - eps &&
                horizontalOverlap >= minOverlap;

              if (landedFromAbove) {
                state.y = obstacleRect.height;
                state.velocity = 0;
                state.isJumping = false;
                state.airFrame = 0;
                state.rotationTarget = state.rotation;
                state.rotationStart = state.rotation;
                state.rotationFrames = totalAirFrames;
                state.onPlatform = true;
                state.platform = obstacle;
                state.fallingFrom = null;
                platformStillUnder = true;
              } else if (checkCollision(squareRect, obstacleRect)) {
                if (!state.onPlatform || state.platform !== obstacle) {
                  triggerGameOver();
                }
              }
            } else if (checkCollision(squareRect, obstacleRect)) {
              triggerGameOver();
            }

            if (state.onPlatform && state.platform === obstacle) {
              const overlapLeft = squareRect.right - obstacleRect.left;
              const overlapRight = obstacleRect.right - squareRect.left;
              if (overlapLeft > 4 && overlapRight > 4) {
                platformStillUnder = true;
                state.y = obstacleRect.height;
              }
            }

          }

          if (state.onPlatform && !platformStillUnder) {
            state.onPlatform = false;
            state.fallingFrom = state.platform;
            state.platform = null;
            state.isJumping = true;
            state.velocity = 0;
            state.airFrame = 0;
            state.rotationStart = state.rotation;
            state.rotationTarget = state.rotation + 90;
            state.rotationFrames = calculateFallFrames(state.y);
          }

          updateSwampTransition(delta, squareRect);
        }

        requestAnimationFrame(update);
      };

      const jump = () => {
        if (!state.isJumping && !state.isGameOver) {
          state.isJumping = true;
          state.velocity = jumpVelocity;
          state.airFrame = 0;
          state.rotationStart = state.rotation;
          state.rotationTarget = state.rotation + 90;
          state.rotationFrames = totalAirFrames;
          state.onPlatform = false;
          state.platform = null;
          state.fallingFrom = null;
        }
      };

      game.addEventListener("pointerdown", (event) => {
        if (event.button !== 0) {
          return;
        }
        if (state.isGameOver) {
          return;
        }
        event.preventDefault();
        state.isHolding = true;
        game.setPointerCapture(event.pointerId);
        jump();
      });

      const stopHolding = () => {
        state.isHolding = false;
      };

      game.addEventListener("pointerup", (event) => {
        if (event.button !== 0) {
          return;
        }
        if (game.hasPointerCapture(event.pointerId)) {
          game.releasePointerCapture(event.pointerId);
        }
        stopHolding();
      });

      game.addEventListener("pointercancel", stopHolding);
      game.addEventListener("pointerleave", stopHolding);

      const handleSpaceDown = (event) => {
        if (event.code !== "Space" && event.key !== " ") {
          return;
        }
        event.preventDefault();
        if (state.isGameOver) {
          return;
        }
        if (state.isHolding) {
          return;
        }
        state.isHolding = true;
        jump();
      };

      const handleSpaceUp = (event) => {
        if (event.code !== "Space" && event.key !== " ") {
          return;
        }
        event.preventDefault();
        stopHolding();
      };

      window.addEventListener("keydown", handleSpaceDown);
      window.addEventListener("keyup", handleSpaceUp);
      retryButton.addEventListener("click", () => {
        if (!state.isGameOver) {
          return;
        }
        resetGame();
      });

      requestAnimationFrame(update);
    </script>
  </body>
</html>
