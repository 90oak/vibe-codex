<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Tyler Dash</title>
    <style>
      :root {
        color-scheme: dark;
        font-family: "Trebuchet MS", "Segoe UI", sans-serif;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        background: radial-gradient(circle at top, #1f2b3a 0%, #0b111a 60%, #05070b 100%);
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .game-shell {
        width: min(960px, 100%);
        aspect-ratio: 16 / 9;
        background: linear-gradient(180deg, rgba(16, 22, 32, 0.9) 0%, rgba(10, 14, 22, 0.95) 50%, rgba(8, 10, 16, 1) 100%);
        border: 2px solid rgba(255, 255, 255, 0.08);
        border-radius: 20px;
        overflow: hidden;
        position: relative;
        box-shadow: 0 30px 80px rgba(0, 0, 0, 0.45);
        touch-action: manipulation;
        --floor-bottom: 16px;
        --floor-height: 90px;
        --floor-top: calc(var(--floor-bottom) + var(--floor-height));
        --floor-grid: 24px;
        --floor-speed: 0.05s;
        --sky-horizon: calc(var(--floor-top) + 2px);
      }

      .game-shell,
      .game-shell * {
        user-select: none;
        -webkit-user-select: none;
        -webkit-touch-callout: none;
      }

      .hud {
        position: absolute;
        inset: 20px 24px auto;
        display: flex;
        flex-direction: column;
        gap: 8px;
        z-index: 3;
      }

      .scoreboard {
        position: absolute;
        top: 20px;
        right: 24px;
        display: flex;
        flex-direction: column;
        align-items: flex-end;
        gap: 4px;
        z-index: 3;
        pointer-events: none;
      }

      .score-label {
        font-size: 0.7rem;
        letter-spacing: 0.2em;
        text-transform: uppercase;
        color: rgba(255, 224, 138, 0.75);
      }

      .score-value {
        position: relative;
        font-size: clamp(1.6rem, 4vw, 2.6rem);
        font-weight: 700;
        letter-spacing: 0.12em;
        color: #ffd572;
        text-shadow: 0 0 12px rgba(255, 213, 114, 0.6);
        padding-right: 14px;
      }

      .score-value.is-updated .score-digits {
        animation: score-pop 0.4s ease, score-glow 2.4s ease-in-out infinite;
      }

      .score-digits {
        display: inline-block;
        animation: score-glow 2.4s ease-in-out infinite;
        text-shadow: 0 0 14px rgba(255, 213, 114, 0.75), 0 0 26px rgba(255, 213, 114, 0.45);
      }

      .score-value::before,
      .score-value::after {
        content: "";
        position: absolute;
        top: 50%;
        right: -4px;
        width: 12px;
        height: 12px;
        border-radius: 50%;
        background: radial-gradient(circle, rgba(255, 233, 173, 0.9), rgba(255, 233, 173, 0));
        transform: translateY(-50%) scale(0.6);
        opacity: 0.7;
        animation: sparkle 1.6s ease-in-out infinite;
      }

      .score-value::after {
        width: 18px;
        height: 18px;
        right: -16px;
        animation-delay: 0.4s;
        opacity: 0.5;
      }

      .score-sparkle {
        position: absolute;
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background: radial-gradient(circle, rgba(255, 233, 173, 0.85), rgba(255, 233, 173, 0));
        opacity: 0.6;
        animation: sparkle 1.8s ease-in-out infinite;
        pointer-events: none;
      }

      .score-sparkle.sparkle-one {
        top: -6px;
        right: 38px;
        animation-delay: 0.2s;
      }

      .score-sparkle.sparkle-two {
        top: 50%;
        right: 26px;
        transform: translateY(-50%);
        animation-delay: 0.7s;
      }

      .score-sparkle.sparkle-three {
        bottom: -8px;
        right: 12px;
        width: 14px;
        height: 14px;
        animation-delay: 1.1s;
      }

      .title {
        font-size: clamp(1.4rem, 3vw, 2.2rem);
        font-weight: 700;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: #d9f6ff;
      }

      .subtitle {
        font-size: clamp(0.85rem, 2vw, 1rem);
        color: rgba(217, 246, 255, 0.65);
      }

      .lane {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: flex-start;
        padding-left: clamp(24px, 6vw, 80px);
        z-index: 2;
      }

      .sky {
        position: absolute;
        inset: 0 0 var(--sky-horizon);
        background:
          linear-gradient(180deg, rgba(153, 227, 255, 0.72) 0%, rgba(129, 212, 255, 0.88) 42%, rgba(178, 232, 255, 0.95) 100%);
        overflow: hidden;
        z-index: 1;
      }

      .sky::before {
        content: "";
        position: absolute;
        inset: 0;
        background:
          repeating-linear-gradient(
            0deg,
            rgba(227, 245, 255, 0.16) 0 2px,
            transparent 2px 24px
          ),
          repeating-linear-gradient(
            90deg,
            rgba(227, 245, 255, 0.2) 0 2px,
            transparent 2px 24px
          );
        opacity: 0.75;
      }

      .cloud-layer {
        position: absolute;
        inset: 0;
        pointer-events: none;
      }

      .cloud {
        position: absolute;
        display: grid;
        grid-auto-flow: column;
        gap: 2px;
        will-change: transform;
      }

      .cloud-cube {
        width: 8px;
        height: 8px;
        border-radius: 1px;
        background: linear-gradient(145deg, #ffffff 0%, #f2fbff 55%, #d8ecf8 100%);
        box-shadow: 0 1px 1px rgba(111, 165, 194, 0.4);
      }

      .grass-field {
        position: absolute;
        left: 0;
        right: 0;
        bottom: var(--floor-top);
        height: clamp(26px, 4.6vw, 38px);
        pointer-events: none;
        overflow: hidden;
        z-index: 3;
      }

      .grass-blade {
        position: absolute;
        bottom: 0;
        width: 12px;
        height: 34px;
        clip-path: polygon(50% 0%, 0% 100%, 100% 100%);
        transform-origin: 50% 100%;
        filter: drop-shadow(0 6px 5px rgba(24, 99, 44, 0.3));
        will-change: transform;
        opacity: 0.95;
      }

      .grass-blade--faded {
        height: 26px;
        width: 10px;
        opacity: 0.88;
        background: linear-gradient(180deg, #8ac08e 0%, #5f9f67 100%);
      }

      .grass-blade--bright {
        height: 36px;
        width: 12px;
        background: linear-gradient(180deg, #8fff7a 0%, #4ecb4e 55%, #26912d 100%);
      }

      .grass-blade.is-swaying {
        animation: grass-sway-back 0.9s cubic-bezier(0.35, 0.12, 0.2, 1);
      }

      .square {
        width: clamp(48px, 7vw, 72px);
        height: clamp(48px, 7vw, 72px);
        background: linear-gradient(145deg, #8ff0ff 0%, #39b6ff 35%, #1b4bd6 100%);
        border-radius: 10px;
        box-shadow: 0 18px 35px rgba(34, 94, 185, 0.45);
        position: absolute;
        left: clamp(24px, 6vw, 80px);
        bottom: var(--floor-top);
        transform: translateY(0);
        transform-origin: center;
      }

      .cube {
        position: absolute;
        bottom: var(--floor-top);
        width: clamp(46px, 6.8vw, 70px);
        height: clamp(46px, 6.8vw, 70px);
        background: linear-gradient(145deg, #8b98ff 0%, #566dff 45%, #2b3fe0 100%);
        border-radius: 2px;
        box-shadow: 0 16px 28px rgba(61, 82, 214, 0.5);
      }

      .spike {
        position: absolute;
        bottom: var(--floor-top);
        width: clamp(46px, 6.5vw, 70px);
        height: clamp(46px, 6.5vw, 70px);
        background: linear-gradient(145deg, #ff7c8c 0%, #f7435a 45%, #c21b37 100%);
        clip-path: polygon(50% 0%, 0% 100%, 100% 100%);
        filter: drop-shadow(0 10px 14px rgba(255, 86, 107, 0.45));
      }

      .game-message {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: clamp(1.8rem, 4vw, 3rem);
        font-weight: 700;
        letter-spacing: 0.12em;
        text-transform: uppercase;
        color: #ff9fb0;
        background: rgba(5, 7, 11, 0.65);
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.2s ease;
        z-index: 4;
        flex-direction: column;
        gap: 16px;
      }

      .game-message.is-visible {
        opacity: 1;
        pointer-events: auto;
      }

      .retry-button {
        border: none;
        border-radius: 999px;
        padding: 12px 26px;
        font-size: 0.95rem;
        letter-spacing: 0.12em;
        text-transform: uppercase;
        font-weight: 700;
        color: #07101b;
        background: linear-gradient(135deg, #ffd86f 0%, #ffb347 60%, #ff9b55 100%);
        box-shadow: 0 14px 24px rgba(255, 184, 91, 0.35);
        cursor: pointer;
      }

      .retry-button:focus-visible {
        outline: 3px solid rgba(255, 216, 111, 0.6);
        outline-offset: 4px;
      }

      .floor {
        position: absolute;
        left: 0;
        right: 0;
        bottom: var(--floor-bottom);
        height: var(--floor-height);
        background:
          repeating-linear-gradient(
            90deg,
            rgba(73, 51, 30, 0.45) 0 2px,
            transparent 2px 32px
          ),
          repeating-linear-gradient(
            0deg,
            rgba(73, 51, 30, 0.35) 0 2px,
            transparent 2px 32px
          ),
          linear-gradient(180deg, #8f6438 0%, #724d2d 52%, #593a22 100%);
        background-size: var(--floor-grid) var(--floor-grid), var(--floor-grid) var(--floor-grid), 100% 100%;
        background-position: 0 0, 0 0, 0 0;
        animation: floor-slide var(--floor-speed) linear infinite;
        border-top: 2px solid rgba(217, 165, 104, 0.9);
      }

      .floor::before {
        content: "";
        position: absolute;
        inset: 14px 0 12px;
        background: repeating-linear-gradient(
          90deg,
          rgba(185, 130, 72, 0.32) 0 18px,
          rgba(101, 68, 38, 0.28) 18px 32px
        );
        opacity: 0.82;
        pointer-events: none;
      }

      .game-shell.is-paused .floor {
        animation-play-state: paused;
      }

      .floor::after {
        content: "";
        position: absolute;
        inset: -12px 0 auto;
        height: 12px;
        background: linear-gradient(90deg, rgba(180, 124, 72, 0.68), rgba(180, 124, 72, 0));
      }

      .floor-shadow {
        position: absolute;
        left: 0;
        right: 0;
        bottom: var(--floor-bottom);
        height: 20px;
        background: radial-gradient(circle at 30% 0%, rgba(141, 95, 57, 0.48), transparent 70%);
        opacity: 0.5;
        filter: blur(6px);
      }

      .ground-plane {
        position: absolute;
        left: 0;
        right: 0;
        bottom: 0;
        height: 120px;
        background: linear-gradient(180deg, rgba(37, 23, 14, 0) 0%, rgba(58, 40, 24, 0.72) 62%, rgba(45, 30, 18, 1) 100%);
      }

      .touch-hint {
        position: absolute;
        bottom: 18px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 0.9rem;
        color: rgba(217, 246, 255, 0.6);
        text-align: center;
        z-index: 2;
        padding: 8px 16px;
        border-radius: 999px;
        background: rgba(6, 12, 20, 0.7);
        border: 1px solid rgba(255, 255, 255, 0.08);
      }

      @keyframes floor-slide {
        0% {
          background-position: 0 0, 0 0, 0 0;
        }
        100% {
          background-position: calc(-1 * var(--floor-grid)) 0, calc(-1 * var(--floor-grid)) 0, 0 0;
        }
      }

      @keyframes sparkle {
        0%,
        100% {
          transform: translateY(-50%) scale(0.6);
          opacity: 0.4;
        }
        50% {
          transform: translateY(-60%) scale(1);
          opacity: 0.9;
        }
      }

      @keyframes score-pop {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.12);
        }
        100% {
          transform: scale(1);
        }
      }

      @keyframes score-glow {
        0%,
        100% {
          text-shadow: 0 0 10px rgba(255, 213, 114, 0.6), 0 0 18px rgba(255, 213, 114, 0.35);
        }
        50% {
          text-shadow: 0 0 16px rgba(255, 213, 114, 0.9), 0 0 32px rgba(255, 213, 114, 0.55);
        }
      }

      @keyframes grass-sway-back {
        0% {
          transform: rotate(0deg) translateY(0);
        }
        40% {
          transform: rotate(-22deg) translateY(1px);
        }
        100% {
          transform: rotate(0deg) translateY(0);
        }
      }

      @media (max-width: 600px) {
        .game-shell {
          border-radius: 0;
          height: 100vh;
          width: 100%;
          aspect-ratio: auto;
        }

        .touch-hint {
          bottom: 12px;
          font-size: 0.8rem;
        }
      }
    </style>
  </head>
  <body>
    <main class="game-shell" id="game">
      <div class="hud">
        <div class="title">Tyler Dash</div>
        <div class="subtitle">Tap to hop. Press & hold to chain jumps • build platform-top-landing</div>
      </div>
      <div class="scoreboard">
        <div class="score-label">Score</div>
        <div class="score-value" id="scoreValue">
          <span class="score-digits">0</span>
          <span class="score-sparkle sparkle-one" aria-hidden="true"></span>
          <span class="score-sparkle sparkle-two" aria-hidden="true"></span>
          <span class="score-sparkle sparkle-three" aria-hidden="true"></span>
        </div>
      </div>
      <div class="sky" aria-hidden="true">
        <div class="cloud-layer" id="cloudLayer"></div>
      </div>
      <div class="lane">
        <div class="square" id="square"></div>
      </div>
      <div class="grass-field" id="grassField" aria-hidden="true"></div>
      <div class="game-message" id="gameMessage">
        <div>Game Over</div>
        <button class="retry-button" id="retryButton" type="button">Retry</button>
      </div>
      <div class="floor-shadow"></div>
      <div class="floor"></div>
      <div class="ground-plane"></div>
      <div class="touch-hint">Tap to hop • Press &amp; hold to chain jumps</div>
    </main>

    <script>
      const square = document.getElementById("square");
      const game = document.getElementById("game");
      const gameMessage = document.getElementById("gameMessage");
      const scoreValue = document.getElementById("scoreValue");
      const retryButton = document.getElementById("retryButton");
      const grassField = document.getElementById("grassField");
      const cloudLayer = document.getElementById("cloudLayer");

      const state = {
        y: 0,
        velocity: 0,
        isJumping: false,
        isHolding: false,
        rotation: 0,
        rotationStart: 0,
        rotationTarget: 0,
        rotationFrames: 0,
        airFrame: 0,
        prevY: 0,
        isGameOver: false,
        onPlatform: false,
        platform: null,
        fallingFrom: null,
        score: 0,
      };

      const gravity = -0.9;
      const jumpVelocity = 16.05;
      const totalAirFrames = Math.ceil((2 * jumpVelocity) / -gravity);
      const obstacleIntervalMs = 3000;
      const obstacleSpeed = 480;
      const obstaclePadding = 24;
      const obstacles = [];
      const obstacleTypes = ["spike", "cube"];
      const grassBlades = [];
      const grassSpawnPadding = 20;
      const grassSpeed = obstacleSpeed * 0.72;
      const grassSpawnIntervalMs = 180;
      const grassSwayIntervalMs = 2400;
      const clouds = [];
      const cloudSpeed = obstacleSpeed * 0.34;
      const cloudSpawnIntervalMs = 1650;
      const cloudSpawnPadding = 120;
      const squareBackEdgeX = () => {
        const squareRect = square.getBoundingClientRect();
        return squareRect.left + squareRect.width * 0.5;
      };

      let lastFrameTime = 0;
      let obstacleTimer = 0;
      let grassSpawnTimer = 0;
      let grassSwayTimer = 0;
      let cloudSpawnTimer = 0;

      const spawnObstacle = () => {
        const obstacle = document.createElement("div");
        const type = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
        obstacle.className = type;
        obstacle.dataset.type = type;
        const startX = game.clientWidth + obstaclePadding;
        obstacle.dataset.x = startX.toString();
        obstacle.style.transform = `translateX(${startX}px)`;
        game.appendChild(obstacle);
        obstacles.push(obstacle);
      };

      const updateScore = () => {
        const digits = scoreValue.querySelector(".score-digits");
        if (digits) {
          digits.textContent = state.score.toString();
        }
        scoreValue.classList.add("is-updated");
        window.setTimeout(() => {
          scoreValue.classList.remove("is-updated");
        }, 350);
      };

      const resetGame = () => {
        state.y = 0;
        state.velocity = 0;
        state.isJumping = false;
        state.isHolding = false;
        state.rotation = 0;
        state.rotationStart = 0;
        state.rotationTarget = 0;
        state.rotationFrames = totalAirFrames;
        state.airFrame = 0;
        state.prevY = 0;
        state.isGameOver = false;
        state.onPlatform = false;
        state.platform = null;
        state.fallingFrom = null;
        state.score = 0;
        obstacleTimer = 0;
        grassSpawnTimer = 0;
        grassSwayTimer = 0;
        cloudSpawnTimer = 0;
        obstacles.splice(0).forEach((obstacle) => obstacle.remove());
        grassBlades.splice(0).forEach((blade) => blade.element.remove());
        clouds.splice(0).forEach((cloud) => cloud.element.remove());
        gameMessage.classList.remove("is-visible");
        game.classList.remove("is-paused");
        updateScore();
      };

      const createCloudShape = () => {
        const rows = 2 + Math.floor(Math.random() * 3);
        const cols = 7 + Math.floor(Math.random() * 7);
        const cubes = [];
        for (let row = 0; row < rows; row += 1) {
          for (let col = 0; col < cols; col += 1) {
            const centerBias = 1 - Math.abs((col - (cols - 1) / 2) / (cols / 2));
            if (Math.random() < 0.3 + centerBias * 0.6) {
              cubes.push({ row, col });
            }
          }
        }
        return cubes;
      };

      const spawnCloud = () => {
        if (!cloudLayer) {
          return;
        }
        const cloud = document.createElement("div");
        cloud.className = "cloud";
        const cubeMap = createCloudShape();
        const cubeSize = 8;
        const maxCol = Math.max(...cubeMap.map((cube) => cube.col), 0);
        const maxRow = Math.max(...cubeMap.map((cube) => cube.row), 0);
        cloud.style.width = `${(maxCol + 1) * (cubeSize + 2)}px`;
        cloud.style.height = `${(maxRow + 1) * (cubeSize + 2)}px`;
        cubeMap.forEach((cube) => {
          const cubeElement = document.createElement("span");
          cubeElement.className = "cloud-cube";
          cubeElement.style.gridColumn = `${cube.col + 1}`;
          cubeElement.style.gridRow = `${cube.row + 1}`;
          cloud.appendChild(cubeElement);
        });

        const startX = game.clientWidth + cloudSpawnPadding;
        const y = 28 + Math.random() * 140;
        cloud.style.transform = `translate(${startX}px, ${y}px)`;
        cloudLayer.appendChild(cloud);
        clouds.push({ element: cloud, x: startX, y });
      };

      const spawnGrassBlade = () => {
        if (!grassField) {
          return;
        }
        const blade = document.createElement("div");
        const isFaded = Math.random() < 0.42;
        blade.className = `grass-blade ${isFaded ? "grass-blade--faded" : "grass-blade--bright"}`;
        const startX = game.clientWidth + grassSpawnPadding + Math.random() * 70;
        const verticalOffset = Math.random() < 0.35 ? Math.random() * 8 : 0;
        blade.style.transform = `translateY(${verticalOffset}px)`;
        blade.style.left = `${startX}px`;
        grassField.appendChild(blade);
        grassBlades.push({ element: blade, x: startX, hasPassedSquare: false, isFaded });
      };

      const swayPassedGrass = () => {
        const passed = grassBlades.filter((blade) => blade.hasPassedSquare);
        if (!passed.length) {
          return;
        }
        const swayCount = Math.min(passed.length, Math.random() < 0.5 ? 2 : 3);
        for (let i = passed.length - 1; i > 0; i -= 1) {
          const swapIndex = Math.floor(Math.random() * (i + 1));
          [passed[i], passed[swapIndex]] = [passed[swapIndex], passed[i]];
        }
        passed.slice(0, swayCount).forEach((blade) => {
          blade.element.classList.remove("is-swaying");
          void blade.element.offsetWidth;
          blade.element.classList.add("is-swaying");
        });
      };

      const triggerGameOver = () => {
        if (state.isGameOver) {
          return;
        }
        state.isGameOver = true;
        state.isJumping = false;
        state.isHolding = false;
        state.velocity = 0;
        state.rotationStart = state.rotation;
        state.rotationTarget = state.rotation;
        state.rotationFrames = totalAirFrames;
        gameMessage.classList.add("is-visible");
        game.classList.add("is-paused");
      };

      const checkCollision = (cubeRect, obstacleRect) => {
        const obstacleInset = Math.min(obstacleRect.width, obstacleRect.height) * 0.16;
        const cubeInset = Math.min(cubeRect.width, cubeRect.height) * 0.08;
        return !(
          cubeRect.right - cubeInset < obstacleRect.left + obstacleInset ||
          cubeRect.left + cubeInset > obstacleRect.right - obstacleInset ||
          cubeRect.bottom - cubeInset < obstacleRect.top + obstacleInset ||
          cubeRect.top + cubeInset > obstacleRect.bottom - obstacleInset
        );
      };

      const getSquareHitbox = (yOverride = state.y) => {
        const gameRect = game.getBoundingClientRect();
        const squareStyle = window.getComputedStyle(square);
        const left = gameRect.left + Number.parseFloat(squareStyle.left || "0");
        const bottom = gameRect.bottom - Number.parseFloat(squareStyle.bottom || "0") - yOverride;
        const width = square.offsetWidth;
        const height = square.offsetHeight;
        return {
          left,
          right: left + width,
          top: bottom - height,
          bottom,
          width,
          height,
        };
      };

      const calculateFallFrames = (height) => {
        const gravityMagnitude = Math.abs(gravity);
        if (height <= 0) {
          return 1;
        }
        const frames = Math.ceil((Math.sqrt(1 + (8 * height) / gravityMagnitude) - 1) / 2);
        return Math.max(frames, 1);
      };

      const update = (time) => {
        if (!lastFrameTime) {
          lastFrameTime = time;
        }
        const delta = Math.min((time - lastFrameTime) / 1000, 0.05);
        lastFrameTime = time;
        state.prevY = state.y;

        if (state.isJumping) {
          state.velocity += gravity;
          state.y += state.velocity;
          state.airFrame += 1;
          const progress = Math.min(state.airFrame / state.rotationFrames, 1);
          state.rotation = state.rotationStart + (state.rotationTarget - state.rotationStart) * progress;

          if (state.y <= 0) {
            state.y = 0;
            state.velocity = 0;
            state.isJumping = false;
            state.rotation = state.rotationTarget % 360;
            state.airFrame = 0;
            state.rotationFrames = totalAirFrames;
            state.onPlatform = false;
            state.platform = null;
            state.fallingFrom = null;
            if (state.isHolding) {
              jump();
            }
          }
        }

        square.style.transform = `translateY(${-state.y}px) rotate(${state.rotation}deg)`;
        if (!state.isGameOver) {
          obstacleTimer += delta * 1000;
          grassSpawnTimer += delta * 1000;
          grassSwayTimer += delta * 1000;
          cloudSpawnTimer += delta * 1000;

          if (grassSpawnTimer >= grassSpawnIntervalMs) {
            grassSpawnTimer = 0;
            spawnGrassBlade();
            if (Math.random() < 0.55) {
              spawnGrassBlade();
            }
          }

          const squarePassX = squareBackEdgeX();
          for (let i = grassBlades.length - 1; i >= 0; i -= 1) {
            const blade = grassBlades[i];
            blade.x -= grassSpeed * delta;
            blade.element.style.left = `${blade.x}px`;

            const bladeRect = blade.element.getBoundingClientRect();
            if (!blade.hasPassedSquare && bladeRect.right < squarePassX) {
              blade.hasPassedSquare = true;
            }

            if (blade.x < -grassSpawnPadding * 2) {
              blade.element.remove();
              grassBlades.splice(i, 1);
            }
          }

          if (grassSwayTimer >= grassSwayIntervalMs) {
            grassSwayTimer = 0;
            swayPassedGrass();
          }

          if (cloudSpawnTimer >= cloudSpawnIntervalMs) {
            cloudSpawnTimer = 0;
            spawnCloud();
          }

          for (let i = clouds.length - 1; i >= 0; i -= 1) {
            const cloud = clouds[i];
            cloud.x -= cloudSpeed * delta;
            cloud.element.style.transform = `translate(${cloud.x}px, ${cloud.y}px)`;

            if (cloud.x < -cloudSpawnPadding * 2.5) {
              cloud.element.remove();
              clouds.splice(i, 1);
            }
          }

          if (obstacleTimer >= obstacleIntervalMs) {
            obstacleTimer = 0;
            spawnObstacle();
          }

          const squareRect = getSquareHitbox(state.y);
          const prevSquareRect = getSquareHitbox(state.prevY);
          let platformStillUnder = false;
          for (let i = obstacles.length - 1; i >= 0; i -= 1) {
            const obstacle = obstacles[i];
            const currentX = Number(obstacle.dataset.x || 0);
            const nextX = currentX - obstacleSpeed * delta;
            obstacle.dataset.x = nextX.toString();
            obstacle.style.transform = `translateX(${nextX}px)`;

            if (nextX < -obstaclePadding * 2) {
              obstacle.remove();
              obstacles.splice(i, 1);
              continue;
            }

            const obstacleRect = obstacle.getBoundingClientRect();
            if (!state.isGameOver && !obstacle.dataset.scored && obstacleRect.right < squareRect.left) {
              if (state.y > 0) {
                state.score += 1;
                updateScore();
              }
              obstacle.dataset.scored = "true";
            }
            if (obstacle.dataset.type === "cube") {
              if (state.fallingFrom === obstacle) {
                continue;
              }
              const horizontalOverlap = Math.min(squareRect.right, obstacleRect.right) - Math.max(squareRect.left, obstacleRect.left);
              const minOverlap = Math.max(10, squareRect.width * 0.25);
              const eps = 2;
              const landedFromAbove =
                state.velocity <= 0 &&
                checkCollision(squareRect, obstacleRect) &&
                prevSquareRect.bottom <= obstacleRect.top + eps &&
                squareRect.bottom >= obstacleRect.top - eps &&
                horizontalOverlap >= minOverlap;

              if (landedFromAbove) {
                state.y = obstacleRect.height;
                state.velocity = 0;
                state.isJumping = false;
                state.airFrame = 0;
                state.rotationTarget = state.rotation;
                state.rotationStart = state.rotation;
                state.rotationFrames = totalAirFrames;
                state.onPlatform = true;
                state.platform = obstacle;
                state.fallingFrom = null;
                platformStillUnder = true;
              } else if (checkCollision(squareRect, obstacleRect)) {
                if (!state.onPlatform || state.platform !== obstacle) {
                  triggerGameOver();
                }
              }
            } else if (checkCollision(squareRect, obstacleRect)) {
              triggerGameOver();
            }

            if (state.onPlatform && state.platform === obstacle) {
              const overlapLeft = squareRect.right - obstacleRect.left;
              const overlapRight = obstacleRect.right - squareRect.left;
              if (overlapLeft > 4 && overlapRight > 4) {
                platformStillUnder = true;
                state.y = obstacleRect.height;
              }
            }

          }

          if (state.onPlatform && !platformStillUnder) {
            state.onPlatform = false;
            state.fallingFrom = state.platform;
            state.platform = null;
            state.isJumping = true;
            state.velocity = 0;
            state.airFrame = 0;
            state.rotationStart = state.rotation;
            state.rotationTarget = state.rotation + 90;
            state.rotationFrames = calculateFallFrames(state.y);
          }
        }

        requestAnimationFrame(update);
      };

      const jump = () => {
        if (!state.isJumping && !state.isGameOver) {
          state.isJumping = true;
          state.velocity = jumpVelocity;
          state.airFrame = 0;
          state.rotationStart = state.rotation;
          state.rotationTarget = state.rotation + 90;
          state.rotationFrames = totalAirFrames;
          state.onPlatform = false;
          state.platform = null;
          state.fallingFrom = null;
        }
      };

      game.addEventListener("pointerdown", (event) => {
        if (event.button !== 0) {
          return;
        }
        if (state.isGameOver) {
          return;
        }
        event.preventDefault();
        state.isHolding = true;
        game.setPointerCapture(event.pointerId);
        jump();
      });

      const stopHolding = () => {
        state.isHolding = false;
      };

      game.addEventListener("pointerup", (event) => {
        if (event.button !== 0) {
          return;
        }
        if (game.hasPointerCapture(event.pointerId)) {
          game.releasePointerCapture(event.pointerId);
        }
        stopHolding();
      });

      game.addEventListener("pointercancel", stopHolding);
      game.addEventListener("pointerleave", stopHolding);

      const handleSpaceDown = (event) => {
        if (event.code !== "Space" && event.key !== " ") {
          return;
        }
        event.preventDefault();
        if (state.isGameOver) {
          return;
        }
        if (state.isHolding) {
          return;
        }
        state.isHolding = true;
        jump();
      };

      const handleSpaceUp = (event) => {
        if (event.code !== "Space" && event.key !== " ") {
          return;
        }
        event.preventDefault();
        stopHolding();
      };

      window.addEventListener("keydown", handleSpaceDown);
      window.addEventListener("keyup", handleSpaceUp);
      retryButton.addEventListener("click", () => {
        if (!state.isGameOver) {
          return;
        }
        resetGame();
      });

      requestAnimationFrame(update);
    </script>
  </body>
</html>
