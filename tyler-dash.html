<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Tyler Dash</title>
    <style>
      :root {
        color-scheme: dark;
        font-family: "Trebuchet MS", "Segoe UI", sans-serif;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        background: radial-gradient(circle at top, #1f2b3a 0%, #0b111a 60%, #05070b 100%);
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .game-shell {
        width: min(960px, 100%);
        aspect-ratio: 16 / 9;
        background: linear-gradient(180deg, rgba(16, 22, 32, 0.9) 0%, rgba(10, 14, 22, 0.95) 50%, rgba(8, 10, 16, 1) 100%);
        border: 2px solid rgba(255, 255, 255, 0.08);
        border-radius: 20px;
        overflow: hidden;
        position: relative;
        box-shadow: 0 30px 80px rgba(0, 0, 0, 0.45);
        touch-action: manipulation;
        --floor-bottom: 70px;
        --floor-height: 90px;
        --floor-top: calc(var(--floor-bottom) + var(--floor-height));
        --floor-grid: 24px;
        --floor-speed: 0.05s;
      }

      .game-shell,
      .game-shell * {
        user-select: none;
        -webkit-user-select: none;
        -webkit-touch-callout: none;
      }

      .hud {
        position: absolute;
        inset: 20px 24px auto;
        display: flex;
        flex-direction: column;
        gap: 8px;
        z-index: 3;
      }

      .scoreboard {
        position: absolute;
        top: 20px;
        right: 24px;
        display: flex;
        flex-direction: column;
        align-items: flex-end;
        gap: 4px;
        z-index: 3;
        pointer-events: none;
      }

      .score-label {
        font-size: 0.7rem;
        letter-spacing: 0.2em;
        text-transform: uppercase;
        color: rgba(255, 224, 138, 0.75);
      }

      .score-value {
        position: relative;
        font-size: clamp(1.6rem, 4vw, 2.6rem);
        font-weight: 700;
        letter-spacing: 0.12em;
        color: #ffd572;
        text-shadow: 0 0 12px rgba(255, 213, 114, 0.6);
        padding-right: 14px;
      }

      .score-value.is-updated .score-digits {
        animation: score-pop 0.4s ease, score-glow 2.4s ease-in-out infinite;
      }

      .score-digits {
        display: inline-block;
        animation: score-glow 2.4s ease-in-out infinite;
        text-shadow: 0 0 14px rgba(255, 213, 114, 0.75), 0 0 26px rgba(255, 213, 114, 0.45);
      }

      .score-value::before,
      .score-value::after {
        content: "";
        position: absolute;
        top: 50%;
        right: -4px;
        width: 12px;
        height: 12px;
        border-radius: 50%;
        background: radial-gradient(circle, rgba(255, 233, 173, 0.9), rgba(255, 233, 173, 0));
        transform: translateY(-50%) scale(0.6);
        opacity: 0.7;
        animation: sparkle 1.6s ease-in-out infinite;
      }

      .score-value::after {
        width: 18px;
        height: 18px;
        right: -16px;
        animation-delay: 0.4s;
        opacity: 0.5;
      }

      .score-sparkle {
        position: absolute;
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background: radial-gradient(circle, rgba(255, 233, 173, 0.85), rgba(255, 233, 173, 0));
        opacity: 0.6;
        animation: sparkle 1.8s ease-in-out infinite;
        pointer-events: none;
      }

      .score-sparkle.sparkle-one {
        top: -6px;
        right: 38px;
        animation-delay: 0.2s;
      }

      .score-sparkle.sparkle-two {
        top: 50%;
        right: 26px;
        transform: translateY(-50%);
        animation-delay: 0.7s;
      }

      .score-sparkle.sparkle-three {
        bottom: -8px;
        right: 12px;
        width: 14px;
        height: 14px;
        animation-delay: 1.1s;
      }

      .title {
        font-size: clamp(1.4rem, 3vw, 2.2rem);
        font-weight: 700;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: #d9f6ff;
      }

      .subtitle {
        font-size: clamp(0.85rem, 2vw, 1rem);
        color: rgba(217, 246, 255, 0.65);
      }

      .lane {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: flex-start;
        padding-left: clamp(24px, 6vw, 80px);
      }

      .square {
        width: clamp(48px, 7vw, 72px);
        height: clamp(48px, 7vw, 72px);
        background: linear-gradient(145deg, #8ff0ff 0%, #39b6ff 35%, #1b4bd6 100%);
        border-radius: 10px;
        box-shadow: 0 18px 35px rgba(34, 94, 185, 0.45);
        position: absolute;
        left: clamp(24px, 6vw, 80px);
        bottom: var(--floor-top);
        transform: translateY(0);
        transform-origin: center;
      }

      .cube {
        position: absolute;
        bottom: var(--floor-top);
        width: clamp(46px, 6.8vw, 70px);
        height: clamp(46px, 6.8vw, 70px);
        background: linear-gradient(145deg, #8b98ff 0%, #566dff 45%, #2b3fe0 100%);
        border-radius: 2px;
        box-shadow: 0 16px 28px rgba(61, 82, 214, 0.5);
      }

      .spike {
        position: absolute;
        bottom: var(--floor-top);
        width: clamp(46px, 6.5vw, 70px);
        height: clamp(46px, 6.5vw, 70px);
        background: linear-gradient(145deg, #ff7c8c 0%, #f7435a 45%, #c21b37 100%);
        clip-path: polygon(50% 0%, 0% 100%, 100% 100%);
        filter: drop-shadow(0 10px 14px rgba(255, 86, 107, 0.45));
      }

      .game-message {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: clamp(1.8rem, 4vw, 3rem);
        font-weight: 700;
        letter-spacing: 0.12em;
        text-transform: uppercase;
        color: #ff9fb0;
        background: rgba(5, 7, 11, 0.65);
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.2s ease;
        z-index: 4;
        flex-direction: column;
        gap: 16px;
      }

      .game-message.is-visible {
        opacity: 1;
        pointer-events: auto;
      }

      .retry-button {
        border: none;
        border-radius: 999px;
        padding: 12px 26px;
        font-size: 0.95rem;
        letter-spacing: 0.12em;
        text-transform: uppercase;
        font-weight: 700;
        color: #07101b;
        background: linear-gradient(135deg, #ffd86f 0%, #ffb347 60%, #ff9b55 100%);
        box-shadow: 0 14px 24px rgba(255, 184, 91, 0.35);
        cursor: pointer;
      }

      .retry-button:focus-visible {
        outline: 3px solid rgba(255, 216, 111, 0.6);
        outline-offset: 4px;
      }

      .floor {
        position: absolute;
        left: 0;
        right: 0;
        bottom: var(--floor-bottom);
        height: var(--floor-height);
        background: repeating-linear-gradient(
            0deg,
            rgba(83, 209, 255, 0.35) 0px,
            rgba(83, 209, 255, 0.35) 1px,
            transparent 1px,
            transparent var(--floor-grid)
          ),
          repeating-linear-gradient(
            90deg,
            rgba(83, 209, 255, 0.35) 0px,
            rgba(83, 209, 255, 0.35) 1px,
            transparent 1px,
            transparent var(--floor-grid)
          ),
          linear-gradient(180deg, #1f3346 0%, #0b1622 100%);
        background-size: var(--floor-grid) var(--floor-grid), var(--floor-grid) var(--floor-grid), 100% 100%;
        background-position: 0 0, 0 0, 0 0;
        animation: floor-slide var(--floor-speed) linear infinite;
      }

      .game-shell.is-paused .floor {
        animation-play-state: paused;
      }

      .floor::after {
        content: "";
        position: absolute;
        inset: -12px 0 auto;
        height: 12px;
        background: linear-gradient(90deg, rgba(83, 209, 255, 0.65), rgba(83, 209, 255, 0));
      }

      .floor-shadow {
        position: absolute;
        left: 0;
        right: 0;
        bottom: var(--floor-bottom);
        height: 20px;
        background: radial-gradient(circle at 30% 0%, rgba(143, 240, 255, 0.6), transparent 70%);
        opacity: 0.5;
        filter: blur(6px);
      }

      .ground-plane {
        position: absolute;
        left: 0;
        right: 0;
        bottom: 0;
        height: 120px;
        background: linear-gradient(180deg, rgba(9, 16, 26, 0) 0%, rgba(8, 13, 22, 0.85) 60%, rgba(5, 8, 13, 1) 100%);
      }

      .touch-hint {
        position: absolute;
        bottom: 18px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 0.9rem;
        color: rgba(217, 246, 255, 0.6);
        text-align: center;
        z-index: 2;
        padding: 8px 16px;
        border-radius: 999px;
        background: rgba(6, 12, 20, 0.7);
        border: 1px solid rgba(255, 255, 255, 0.08);
      }

      @keyframes floor-slide {
        0% {
          background-position: 0 0, 0 0, 0 0;
        }
        100% {
          background-position: calc(-1 * var(--floor-grid)) 0, calc(-1 * var(--floor-grid)) 0, 0 0;
        }
      }

      @keyframes sparkle {
        0%,
        100% {
          transform: translateY(-50%) scale(0.6);
          opacity: 0.4;
        }
        50% {
          transform: translateY(-60%) scale(1);
          opacity: 0.9;
        }
      }

      @keyframes score-pop {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.12);
        }
        100% {
          transform: scale(1);
        }
      }

      @keyframes score-glow {
        0%,
        100% {
          text-shadow: 0 0 10px rgba(255, 213, 114, 0.6), 0 0 18px rgba(255, 213, 114, 0.35);
        }
        50% {
          text-shadow: 0 0 16px rgba(255, 213, 114, 0.9), 0 0 32px rgba(255, 213, 114, 0.55);
        }
      }

      @media (max-width: 600px) {
        .game-shell {
          border-radius: 0;
          height: 100vh;
          width: 100%;
          aspect-ratio: auto;
        }

        .touch-hint {
          bottom: 12px;
          font-size: 0.8rem;
        }
      }
    </style>
  </head>
  <body>
    <main class="game-shell" id="game">
      <div class="hud">
        <div class="title">Tyler Dash</div>
        <div class="subtitle">Tap to hop. Press & hold to chain jumps.</div>
      </div>
      <div class="scoreboard">
        <div class="score-label">Score</div>
        <div class="score-value" id="scoreValue">
          <span class="score-digits">0</span>
          <span class="score-sparkle sparkle-one" aria-hidden="true"></span>
          <span class="score-sparkle sparkle-two" aria-hidden="true"></span>
          <span class="score-sparkle sparkle-three" aria-hidden="true"></span>
        </div>
      </div>
      <div class="lane">
        <div class="square" id="square"></div>
      </div>
      <div class="game-message" id="gameMessage">
        <div>Game Over</div>
        <button class="retry-button" id="retryButton" type="button">Retry</button>
      </div>
      <div class="floor-shadow"></div>
      <div class="floor"></div>
      <div class="ground-plane"></div>
      <div class="touch-hint">Tap to hop â€¢ Press &amp; hold to chain jumps</div>
    </main>

    <script>
      const square = document.getElementById("square");
      const game = document.getElementById("game");
      const gameMessage = document.getElementById("gameMessage");
      const scoreValue = document.getElementById("scoreValue");
      const retryButton = document.getElementById("retryButton");

      const state = {
        y: 0,
        velocity: 0,
        isJumping: false,
        isHolding: false,
        rotation: 0,
        rotationStart: 0,
        rotationTarget: 0,
        rotationFrames: 0,
        airFrame: 0,
        isGameOver: false,
        onPlatform: false,
        platform: null,
        fallingFrom: null,
        score: 0,
      };

      const gravity = -0.9;
      const jumpVelocity = 16.05;
      const totalAirFrames = Math.ceil((2 * jumpVelocity) / -gravity);
      const obstacleIntervalMs = 3000;
      const obstacleSpeed = 480;
      const obstaclePadding = 24;
      const obstacles = [];
      const obstacleTypes = ["spike", "cube"];

      let lastFrameTime = 0;
      let obstacleTimer = 0;

      const spawnObstacle = () => {
        const obstacle = document.createElement("div");
        const type = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
        obstacle.className = type;
        obstacle.dataset.type = type;
        const startX = game.clientWidth + obstaclePadding;
        obstacle.dataset.x = startX.toString();
        obstacle.style.transform = `translateX(${startX}px)`;
        game.appendChild(obstacle);
        obstacles.push(obstacle);
      };

      const updateScore = () => {
        const digits = scoreValue.querySelector(".score-digits");
        if (digits) {
          digits.textContent = state.score.toString();
        }
        scoreValue.classList.add("is-updated");
        window.setTimeout(() => {
          scoreValue.classList.remove("is-updated");
        }, 350);
      };

      const resetGame = () => {
        state.y = 0;
        state.velocity = 0;
        state.isJumping = false;
        state.isHolding = false;
        state.rotation = 0;
        state.rotationStart = 0;
        state.rotationTarget = 0;
        state.rotationFrames = totalAirFrames;
        state.airFrame = 0;
        state.isGameOver = false;
        state.onPlatform = false;
        state.platform = null;
        state.fallingFrom = null;
        state.score = 0;
        obstacleTimer = 0;
        obstacles.splice(0).forEach((obstacle) => obstacle.remove());
        gameMessage.classList.remove("is-visible");
        game.classList.remove("is-paused");
        updateScore();
      };

      const triggerGameOver = () => {
        if (state.isGameOver) {
          return;
        }
        state.isGameOver = true;
        state.isJumping = false;
        state.isHolding = false;
        state.velocity = 0;
        state.rotationStart = state.rotation;
        state.rotationTarget = state.rotation;
        state.rotationFrames = totalAirFrames;
        gameMessage.classList.add("is-visible");
        game.classList.add("is-paused");
      };

      const checkCollision = (cubeRect, obstacleRect) => {
        const obstacleInset = Math.min(obstacleRect.width, obstacleRect.height) * 0.16;
        const cubeInset = Math.min(cubeRect.width, cubeRect.height) * 0.08;
        return !(
          cubeRect.right - cubeInset < obstacleRect.left + obstacleInset ||
          cubeRect.left + cubeInset > obstacleRect.right - obstacleInset ||
          cubeRect.bottom - cubeInset < obstacleRect.top + obstacleInset ||
          cubeRect.top + cubeInset > obstacleRect.bottom - obstacleInset
        );
      };

      const calculateFallFrames = (height) => {
        const gravityMagnitude = Math.abs(gravity);
        if (height <= 0) {
          return 1;
        }
        const frames = Math.ceil((Math.sqrt(1 + (8 * height) / gravityMagnitude) - 1) / 2);
        return Math.max(frames, 1);
      };

      const update = (time) => {
        if (!lastFrameTime) {
          lastFrameTime = time;
        }
        const delta = Math.min((time - lastFrameTime) / 1000, 0.05);
        lastFrameTime = time;

        if (state.isJumping) {
          state.velocity += gravity;
          state.y += state.velocity;
          state.airFrame += 1;
          const progress = Math.min(state.airFrame / state.rotationFrames, 1);
          state.rotation = state.rotationStart + (state.rotationTarget - state.rotationStart) * progress;

          if (state.y <= 0) {
            state.y = 0;
            state.velocity = 0;
            state.isJumping = false;
            state.rotation = state.rotationTarget % 360;
            state.airFrame = 0;
            state.rotationFrames = totalAirFrames;
            state.onPlatform = false;
            state.platform = null;
            state.fallingFrom = null;
            if (state.isHolding) {
              jump();
            }
          }
        }

        square.style.transform = `translateY(${-state.y}px) rotate(${state.rotation}deg)`;
        if (!state.isGameOver) {
          obstacleTimer += delta * 1000;
          if (obstacleTimer >= obstacleIntervalMs) {
            obstacleTimer = 0;
            spawnObstacle();
          }

          const squareRect = square.getBoundingClientRect();
          let platformStillUnder = false;
          for (let i = obstacles.length - 1; i >= 0; i -= 1) {
            const obstacle = obstacles[i];
            const currentX = Number(obstacle.dataset.x || 0);
            const nextX = currentX - obstacleSpeed * delta;
            obstacle.dataset.x = nextX.toString();
            obstacle.style.transform = `translateX(${nextX}px)`;

            if (nextX < -obstaclePadding * 2) {
              obstacle.remove();
              obstacles.splice(i, 1);
              continue;
            }

            const obstacleRect = obstacle.getBoundingClientRect();
            if (!state.isGameOver && !obstacle.dataset.scored && obstacleRect.right < squareRect.left) {
              if (state.y > 0) {
                state.score += 1;
                updateScore();
              }
              obstacle.dataset.scored = "true";
            }
            if (obstacle.dataset.type === "cube") {
              if (state.fallingFrom === obstacle) {
                continue;
              }
              const landingTolerance = Math.max(6, squareRect.height * 0.12);
              const edgeBuffer = Math.max(6, squareRect.width * 0.18);
              const isOverSafeSurface =
                squareRect.left >= obstacleRect.left + edgeBuffer &&
                squareRect.right <= obstacleRect.right - edgeBuffer;
              const isLanding =
                state.velocity <= 0 &&
                squareRect.bottom <= obstacleRect.top + landingTolerance &&
                checkCollision(squareRect, obstacleRect) &&
                isOverSafeSurface;

              if (isLanding) {
                state.y = obstacleRect.height;
                state.velocity = 0;
                state.isJumping = false;
                state.airFrame = 0;
                state.rotationTarget = state.rotation;
                state.rotationStart = state.rotation;
                state.rotationFrames = totalAirFrames;
                state.onPlatform = true;
                state.platform = obstacle;
                state.fallingFrom = null;
              } else if (checkCollision(squareRect, obstacleRect)) {
                if (!state.onPlatform || state.platform !== obstacle) {
                  triggerGameOver();
                }
              }
            } else if (checkCollision(squareRect, obstacleRect)) {
              triggerGameOver();
            }

            if (state.onPlatform && state.platform === obstacle) {
              const overlapLeft = squareRect.right - obstacleRect.left;
              const overlapRight = obstacleRect.right - squareRect.left;
              if (overlapLeft > 4 && overlapRight > 4) {
                platformStillUnder = true;
                state.y = obstacleRect.height;
              }
            }

          }

          if (state.onPlatform && !platformStillUnder) {
            state.onPlatform = false;
            state.fallingFrom = state.platform;
            state.platform = null;
            state.isJumping = true;
            state.velocity = 0;
            state.airFrame = 0;
            state.rotationStart = state.rotation;
            state.rotationTarget = state.rotation + 90;
            state.rotationFrames = calculateFallFrames(state.y);
          }
        }

        requestAnimationFrame(update);
      };

      const jump = () => {
        if (!state.isJumping && !state.isGameOver) {
          state.isJumping = true;
          state.velocity = jumpVelocity;
          state.airFrame = 0;
          state.rotationStart = state.rotation;
          state.rotationTarget = state.rotation + 90;
          state.rotationFrames = totalAirFrames;
          state.onPlatform = false;
          state.platform = null;
          state.fallingFrom = null;
        }
      };

      game.addEventListener("pointerdown", (event) => {
        if (event.button !== 0) {
          return;
        }
        if (state.isGameOver) {
          return;
        }
        event.preventDefault();
        state.isHolding = true;
        game.setPointerCapture(event.pointerId);
        jump();
      });

      const stopHolding = () => {
        state.isHolding = false;
      };

      game.addEventListener("pointerup", (event) => {
        if (event.button !== 0) {
          return;
        }
        if (game.hasPointerCapture(event.pointerId)) {
          game.releasePointerCapture(event.pointerId);
        }
        stopHolding();
      });

      game.addEventListener("pointercancel", stopHolding);
      game.addEventListener("pointerleave", stopHolding);

      const handleSpaceDown = (event) => {
        if (event.code !== "Space" && event.key !== " ") {
          return;
        }
        event.preventDefault();
        if (state.isGameOver) {
          return;
        }
        if (state.isHolding) {
          return;
        }
        state.isHolding = true;
        jump();
      };

      const handleSpaceUp = (event) => {
        if (event.code !== "Space" && event.key !== " ") {
          return;
        }
        event.preventDefault();
        stopHolding();
      };

      window.addEventListener("keydown", handleSpaceDown);
      window.addEventListener("keyup", handleSpaceUp);
      retryButton.addEventListener("click", () => {
        if (!state.isGameOver) {
          return;
        }
        resetGame();
      });

      requestAnimationFrame(update);
    </script>
  </body>
</html>
