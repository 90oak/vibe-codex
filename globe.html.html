<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 3D Globe</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #0c0c1a; 
            font-family: 'Inter', sans-serif;
            color: #fff;
        }
        canvas { 
            display: block; 
        }
        #info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 10px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            max-width: 300px;
        }
        h1 {
            margin: 0 0 10px 0;
            font-size: 1.2em;
        }
        p {
            margin: 0;
            font-size: 0.9em;
            line-height: 1.4;
        }
    </style>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap">
</head>
<body>

    <div id="info-panel">
        <h1>Interactive Globe</h1>
        <p>Drag with your mouse to rotate the Earth. The lighting dynamically updates to show the current day and night cycle.</p>
    </div>

    <script type="module">
        // Import necessary components from three.js library
        import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
        import { OrbitControls } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/controls/OrbitControls.js';

        // --- SCENE, CAMERA, AND RENDERER SETUP ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 3;
        const renderer = new THREE.WebGLRenderer({ 
            antialias: true,
            alpha: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // --- EARTH GEOMETRY AND TEXTURE ---
        const earthGeometry = new THREE.SphereGeometry(1, 64, 64);
        const textureLoader = new THREE.TextureLoader();
        const earthTexture = textureLoader.load(
            'https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg',
            () => {
                console.log("Earth texture loaded successfully.");
                animate();
            },
            undefined,
            (error) => {
                console.error('An error occurred while loading the texture:', error);
                const fallbackMaterial = new THREE.MeshStandardMaterial({ color: 0x0077ff, roughness: 0.8 });
                earth.material = fallbackMaterial;
                animate();
            }
        );
        const earthMaterial = new THREE.MeshStandardMaterial({
            map: earthTexture,
            roughness: 0.85, 
            metalness: 0.1 
        });
        const earth = new THREE.Mesh(earthGeometry, earthMaterial);
        scene.add(earth);

        // --- LIGHTING SETUP ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.15);
        scene.add(ambientLight);
        const sunLight = new THREE.DirectionalLight(0xffffff, 2.5);
        scene.add(sunLight);

        // --- STARFIELD BACKGROUND ---
        const starVertices = [];
        for (let i = 0; i < 10000; i++) {
            const x = (Math.random() - 0.5) * 2000;
            const y = (Math.random() - 0.5) * 2000;
            const z = (Math.random() - 0.5) * 2000;
            const dist = x*x + y*y + z*z;
            if (dist > 10000 && dist < 800000) { 
                 starVertices.push(x, y, z);
            }
        }
        const starGeometry = new THREE.BufferGeometry();
        starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
        const starMaterial = new THREE.PointsMaterial({ 
            color: 0xffffff,
            size: 0.3,
            transparent: true,
            opacity: 0.8
        });
        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);

        // --- CONTROLS ---
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; 
        controls.dampingFactor = 0.05;
        controls.minDistance = 1.5; 
        controls.maxDistance = 10;  
        controls.enablePan = false; 

        // --- DYNAMIC SUN POSITION CALCULATION ---
        function updateSunPosition() {
            const now = new Date();
            
            // Calculate the time of day as a fraction (0 to 1) based on UTC
            const timeFraction = (now.getUTCHours() * 3600 + now.getUTCMinutes() * 60 + now.getUTCSeconds()) / 86400;
            
            // Calculate the day of the year (1 to 365/366)
            const start = new Date(now.getUTCFullYear(), 0, 0);
            const diff = now - start;
            const oneDay = 1000 * 60 * 60 * 24;
            const dayOfYear = Math.floor(diff / oneDay);

            // Approximate Earth's axial tilt (declination)
            const declination = -23.45 * Math.cos(2 * Math.PI / 365 * (dayOfYear + 10)) * (Math.PI / 180);

            // ** FIXED LOGIC **
            // Calculate the longitude where it's currently noon.
            // Noon is at 180 degrees at midnight UTC, and 0 degrees at noon UTC.
            const noonLongitude = (0.5 - timeFraction) * 2 * Math.PI;

            // Calculate the sun's position in 3D space based on this longitude and the seasonal tilt.
            // This correctly positions the sun relative to the fixed texture map.
            const sunX = Math.cos(noonLongitude) * Math.cos(declination);
            const sunY = Math.sin(declination);
            const sunZ = Math.sin(noonLongitude) * Math.cos(declination);

            sunLight.position.set(sunX, sunY, sunZ).normalize();
        }

        // --- ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            updateSunPosition();
            stars.rotation.y += 0.00005;
            controls.update();
            renderer.render(scene, camera);
        }

        // --- RESIZE HANDLER ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Initial call to set the sun position
        updateSunPosition();
    </script>
</body>
</html>

