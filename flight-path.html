<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Flight Path Globe</title>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" />
    <style>
      :root {
        color-scheme: light dark;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        overflow: hidden;
        background-color: #0c0c1a;
        font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        color: #fff;
      }

      canvas {
        display: block;
      }

      #scene {
        position: fixed;
        inset: 0;
      }

      #info-panel {
        position: absolute;
        top: 18px;
        left: 18px;
        padding: 14px 16px;
        background: rgba(0, 0, 0, 0.65);
        border-radius: 14px;
        backdrop-filter: blur(6px);
        border: 1px solid rgba(255, 255, 255, 0.18);
        width: min(270px, calc(100% - 36px));
      }

      h1 {
        margin: 0 0 10px 0;
        font-size: clamp(1.1rem, 3vw, 1.4rem);
      }

      p {
        margin: 0 0 12px 0;
        font-size: 0.95rem;
        line-height: 1.45;
        color: rgba(255, 255, 255, 0.78);
      }

      .inputs {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
        gap: 0.65rem;
        margin-bottom: 0.35rem;
      }

      label {
        display: block;
        margin-bottom: 0.35rem;
        color: rgba(255, 255, 255, 0.7);
        font-size: 0.88rem;
      }

      input[type="text"] {
        width: 100%;
        padding: 0.55rem 0.75rem;
        border-radius: 9px;
        border: 1px solid rgba(255, 255, 255, 0.15);
        background: rgba(255, 255, 255, 0.04);
        color: #fff;
        outline: none;
        font-size: 0.92rem;
        transition: border 120ms ease, box-shadow 120ms ease;
      }

      input[type="text"]:focus {
        border-color: #7ae1ff;
        box-shadow: 0 0 0 3px rgba(122, 225, 255, 0.2);
      }

      button {
        margin-top: 0.4rem;
        padding: 0.85rem 1.1rem;
        border: none;
        border-radius: 10px;
        background: linear-gradient(120deg, #76f7ff, #7affc7);
        color: #001c28;
        font-weight: 700;
        cursor: pointer;
        box-shadow: 0 12px 30px rgba(118, 247, 255, 0.25);
        transition: transform 120ms ease, box-shadow 140ms ease;
      }

      button:active {
        transform: translateY(1px);
      }

      #error {
        min-height: 1.2rem;
        color: #ffc2c2;
        margin-top: 0.35rem;
        font-size: 0.95rem;
      }

      #legend {
        display: flex;
        gap: 0.6rem;
        align-items: center;
        color: rgba(255, 255, 255, 0.7);
        font-size: 0.9rem;
        margin-top: 0.45rem;
      }

      .dot {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        display: inline-block;
      }

      .origin {
        background: #7ae1ff;
        box-shadow: 0 0 12px rgba(122, 225, 255, 0.9);
      }

      .destination {
        background: #ffd166;
        box-shadow: 0 0 12px rgba(255, 209, 102, 0.9);
      }

      @media (max-width: 640px) {
        #info-panel {
          top: 12px;
          left: 12px;
          width: calc(100% - 24px);
        }
      }
    </style>
  </head>
  <body>
    <div id="scene"></div>
    <div id="info-panel">
      <h1>Flight Path Globe</h1>
      <p>Select two airports to draw a smooth great-circle path on the high-fidelity globe.</p>
      <div class="inputs">
        <div>
          <label for="from">Departure airport</label>
          <input id="from" list="airportOptions" type="text" placeholder="e.g. LAX, Los Angeles" />
        </div>
        <div>
          <label for="to">Arrival airport</label>
          <input id="to" list="airportOptions" type="text" placeholder="e.g. JFK, New York" />
        </div>
      </div>
      <datalist id="airportOptions"></datalist>
      <button id="plot">Plot route</button>
      <div id="error"></div>
      <div id="legend"><span class="dot origin"></span> Departure <span class="dot destination"></span> Arrival</div>
    </div>

    <script type="module">
      import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
      import { OrbitControls } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/controls/OrbitControls.js';

      const airports = [
        { city: 'Los Angeles', name: 'Los Angeles Intl', code: 'LAX', lat: 33.9416, lon: -118.4085 },
        { city: 'New York', name: 'John F. Kennedy', code: 'JFK', lat: 40.6413, lon: -73.7781 },
        { city: 'London', name: 'Heathrow', code: 'LHR', lat: 51.47, lon: -0.4543 },
        { city: 'Paris', name: 'Charles de Gaulle', code: 'CDG', lat: 49.0097, lon: 2.5479 },
        { city: 'Tokyo', name: 'Haneda', code: 'HND', lat: 35.5494, lon: 139.7798 },
        { city: 'Sydney', name: 'Kingsford Smith', code: 'SYD', lat: -33.9399, lon: 151.1753 },
        { city: 'Dubai', name: 'Dubai International', code: 'DXB', lat: 25.2532, lon: 55.3657 },
        { city: 'Singapore', name: 'Changi', code: 'SIN', lat: 1.3644, lon: 103.9915 },
        { city: 'Toronto', name: 'Pearson', code: 'YYZ', lat: 43.6777, lon: -79.6248 },
        { city: 'São Paulo', name: 'Guarulhos', code: 'GRU', lat: -23.4356, lon: -46.4731 },
        { city: 'Johannesburg', name: 'OR Tambo', code: 'JNB', lat: -26.1337, lon: 28.242 },
        { city: 'Delhi', name: 'Indira Gandhi', code: 'DEL', lat: 28.5562, lon: 77.1 }
      ];

      const sceneEl = document.getElementById('scene');
      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      sceneEl.appendChild(renderer.domElement);

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 3;

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.minDistance = 1.5;
      controls.maxDistance = 10;
      controls.enablePan = false;

      const earthRadius = 1;
      const earthGeometry = new THREE.SphereGeometry(earthRadius, 64, 64);
      const textureLoader = new THREE.TextureLoader();
      const earthTexture = textureLoader.load(
        'https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg',
        () => {
          startAnimation();
        },
        undefined,
        (error) => {
          console.error('An error occurred while loading the texture:', error);
          const fallbackMaterial = new THREE.MeshStandardMaterial({ color: 0x0077ff, roughness: 0.8 });
          earth.material = fallbackMaterial;
          startAnimation();
        }
      );
      const earthMaterial = new THREE.MeshStandardMaterial({ map: earthTexture, roughness: 0.85, metalness: 0.1 });
      const earth = new THREE.Mesh(earthGeometry, earthMaterial);
      scene.add(earth);

      const ambientLight = new THREE.AmbientLight(0xffffff, 0.15);
      scene.add(ambientLight);
      const sunLight = new THREE.DirectionalLight(0xffffff, 2.5);
      scene.add(sunLight);

      const starVertices = [];
      for (let i = 0; i < 10000; i++) {
        const x = (Math.random() - 0.5) * 2000;
        const y = (Math.random() - 0.5) * 2000;
        const z = (Math.random() - 0.5) * 2000;
        const dist = x * x + y * y + z * z;
        if (dist > 10000 && dist < 800000) {
          starVertices.push(x, y, z);
        }
      }
      const starGeometry = new THREE.BufferGeometry();
      starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
      const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.3, transparent: true, opacity: 0.8 });
      const stars = new THREE.Points(starGeometry, starMaterial);
      scene.add(stars);

      const markers = new THREE.Group();
      const routes = new THREE.Group();
      scene.add(markers, routes);

      const toRadians = THREE.MathUtils.degToRad;
      const latLonToVector3 = (lat, lon, radius = earthRadius) => {
        const phi = toRadians(lat);
        const theta = toRadians(lon - 180);
        const x = -(radius * Math.cos(phi) * Math.cos(theta));
        const y = radius * Math.sin(phi);
        const z = radius * Math.cos(phi) * Math.sin(theta);
        return new THREE.Vector3(x, y, z);
      };

      const addGlowMarker = (position, color) => {
        const marker = new THREE.Mesh(
          new THREE.SphereGeometry(0.014, 20, 20),
          new THREE.MeshBasicMaterial({ color })
        );
        marker.position.copy(position.clone().setLength(earthRadius + 0.003));
        markers.add(marker);
      };

      const airportOptions = document.getElementById('airportOptions');
      airports.forEach((airport) => {
        const option = document.createElement('option');
        option.value = `${airport.code} — ${airport.city}`;
        airportOptions.appendChild(option);
      });

      const errorEl = document.getElementById('error');
      const fromInput = document.getElementById('from');
      const toInput = document.getElementById('to');
      const plotBtn = document.getElementById('plot');

      const normalizeInput = (value) => value.trim().toLowerCase();
      const findAirport = (value) => {
        const normalizedValue = normalizeInput(value);
        const tokens = normalizedValue
          .split(/[—-]/)
          .map((part) => part.trim())
          .filter(Boolean);
        const candidates = [normalizedValue, ...tokens].filter(Boolean);

        return airports.find((airport) => {
          const code = normalizeInput(airport.code);
          const city = normalizeInput(airport.city);
          const name = normalizeInput(airport.name);
          return candidates.some((candidate) => candidate === code || candidate === city || candidate === name);
        });
      };

      const clearRoute = () => {
        while (routes.children.length) routes.remove(routes.children[0]);
        while (markers.children.length) markers.remove(markers.children[0]);
      };

      const buildCurve = (start, end) => {
        const startVec = latLonToVector3(start.lat, start.lon).normalize();
        const endVec = latLonToVector3(end.lat, end.lon).normalize();

        let axis = new THREE.Vector3().crossVectors(startVec, endVec);
        if (axis.lengthSq() === 0) {
          axis = new THREE.Vector3(0, 1, 0).cross(startVec);
        }
        if (axis.lengthSq() === 0) {
          axis = new THREE.Vector3(1, 0, 0);
        }
        axis.normalize();

        const angle = startVec.angleTo(endVec);
        const segments = 256;
        const points = [];
        for (let i = 0; i <= segments; i++) {
          const t = i / segments;
          const point = startVec
            .clone()
            .applyAxisAngle(axis, angle * t)
            .setLength(earthRadius + 0.003);
          points.push(point);
        }

        const curve = new THREE.CatmullRomCurve3(points);
        const tube = new THREE.TubeGeometry(curve, 256, 0.0075, 10, false);
        const gradient = new THREE.MeshBasicMaterial({ color: 0x7ae1ff, transparent: true, opacity: 0.92 });
        const mesh = new THREE.Mesh(tube, gradient);
        return { mesh, startVec: startVec.clone().setLength(earthRadius), endVec: endVec.clone().setLength(earthRadius) };
      };

      const plotRoute = () => {
        const fromAirport = findAirport(fromInput.value);
        const toAirport = findAirport(toInput.value);
        clearRoute();

        if (!fromAirport || !toAirport) {
          errorEl.textContent = 'Please pick two airports from the list.';
          return;
        }
        if (fromAirport.code === toAirport.code) {
          errorEl.textContent = 'Choose two different airports to draw a path.';
          return;
        }

        const { mesh, startVec, endVec } = buildCurve(fromAirport, toAirport);
        routes.add(mesh);
        addGlowMarker(startVec, 0x7ae1ff);
        addGlowMarker(endVec, 0xffd166);
        errorEl.textContent = `${fromAirport.code} ➜ ${toAirport.code}`;
      };

      plotBtn.addEventListener('click', plotRoute);
      [fromInput, toInput].forEach((input) => {
        input.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') plotRoute();
        });
      });

      const onResize = () => {
        const { innerWidth, innerHeight } = window;
        renderer.setSize(innerWidth, innerHeight);
        camera.aspect = innerWidth / innerHeight;
        camera.updateProjectionMatrix();
      };
      window.addEventListener('resize', onResize);

      function updateSunPosition() {
        const now = new Date();
        const timeFraction = (now.getUTCHours() * 3600 + now.getUTCMinutes() * 60 + now.getUTCSeconds()) / 86400;
        const start = new Date(now.getUTCFullYear(), 0, 0);
        const diff = now - start;
        const oneDay = 1000 * 60 * 60 * 24;
        const dayOfYear = Math.floor(diff / oneDay);
        const declination = -23.45 * Math.cos((2 * Math.PI) / 365 * (dayOfYear + 10)) * (Math.PI / 180);
        const noonLongitude = (0.5 - timeFraction) * 2 * Math.PI;
        const sunX = Math.cos(noonLongitude) * Math.cos(declination);
        const sunY = Math.sin(declination);
        const sunZ = Math.sin(noonLongitude) * Math.cos(declination);
        sunLight.position.set(sunX, sunY, sunZ).normalize();
      }

      let animationStarted = false;
      function startAnimation() {
        if (animationStarted) return;
        animationStarted = true;
        animate();
      }

      function animate() {
        requestAnimationFrame(animate);
        updateSunPosition();
        stars.rotation.y += 0.00005;
        controls.update();
        renderer.render(scene, camera);
      }

      updateSunPosition();
      startAnimation();
    </script>
  </body>
</html>
