<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Flight Path Globe</title>
  <style>
    :root {
      color-scheme: light dark;
      --panel-bg: rgba(18, 18, 22, 0.72);
      --accent: #00e0ff;
      --muted: #a7b2c0;
      --text: #f4f6fb;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #05070e;
      color: var(--text);
      overflow: hidden;
    }

    #globeContainer {
      position: fixed;
      inset: 0;
      background: radial-gradient(circle at 45% 40%, #0d1629, #03060f 55%);
    }

    #globeContainer canvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    #ui {
      position: fixed;
      top: 1.25rem;
      left: 1.25rem;
      transform: none;
      width: min(440px, calc(100% - 2.5rem));
      background: var(--panel-bg);
      backdrop-filter: blur(18px);
      border: 1px solid rgba(255, 255, 255, 0.08);
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.45);
      border-radius: 18px;
      padding: 1.25rem 1.5rem 1rem;
      z-index: 10;
    }

    #ui h1 {
      margin: 0 0 0.35rem 0;
      font-size: clamp(1.1rem, 3vw, 1.4rem);
      letter-spacing: 0.02em;
    }

    #ui p {
      margin: 0.15rem 0 0.75rem 0;
      color: var(--muted);
      font-size: 0.95rem;
    }

    .inputs {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 0.75rem;
    }

    label {
      font-size: 0.85rem;
      color: var(--muted);
      display: block;
      margin-bottom: 0.35rem;
    }

    input[type="text"] {
      width: 100%;
      padding: 0.75rem 0.85rem;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      background: rgba(12, 12, 16, 0.75);
      color: var(--text);
      font-size: 0.98rem;
      outline: none;
      transition: border 120ms ease, box-shadow 120ms ease;
    }

    input[type="text"]:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 4px rgba(0, 224, 255, 0.12);
    }

    button {
      margin-top: 0.35rem;
      padding: 0.8rem 1.25rem;
      border: none;
      border-radius: 12px;
      background: linear-gradient(120deg, #00e0ff, #4df3c9);
      color: #001018;
      font-weight: 700;
      letter-spacing: 0.01em;
      cursor: pointer;
      transition: transform 120ms ease, box-shadow 120ms ease, opacity 160ms ease;
      box-shadow: 0 12px 30px rgba(0, 224, 255, 0.25);
    }

    button:active {
      transform: translateY(1px);
    }

    #error {
      min-height: 1.25rem;
      color: #ffb1b1;
      margin-top: 0.35rem;
      font-size: 0.95rem;
    }

    .hint {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.9rem;
    }

    .legend-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: #ffd166;
      display: inline-block;
      box-shadow: 0 0 14px rgba(255, 209, 102, 0.7);
    }

    @media (max-width: 640px) {
      #ui {
        top: 0.75rem;
        left: 0.75rem;
        width: calc(100% - 1.5rem);
        padding: 1rem 1rem 0.85rem;
      }
    }
  </style>
</head>
<body>
  <div id="globeContainer"></div>

  <div id="ui">
    <h1>Direct Flight Path Globe</h1>
    <p>Enter two airports by name or IATA code, then explore the live day/night globe. Major time zone hubs are highlighted.</p>

    <div class="inputs">
      <div>
        <label for="fromInput">Departure airport</label>
        <input id="fromInput" list="airportOptions" type="text" placeholder="e.g. LAX, Los Angeles" />
      </div>
      <div>
        <label for="toInput">Arrival airport</label>
        <input id="toInput" list="airportOptions" type="text" placeholder="e.g. JFK, New York" />
      </div>
    </div>
    <datalist id="airportOptions"></datalist>
    <button id="plotBtn">Show flight path</button>
    <div id="error"></div>
    <p class="hint"><span class="legend-dot"></span> One city per time zone is marked with its airport code.</p>
  </div>

  <script>
    const airportData = [
      { city: 'Auckland', name: 'Auckland Airport', code: 'AKL', country: 'New Zealand', lat: -37.0082, lon: 174.785 },
      { city: 'Sydney', name: 'Sydney Kingsford Smith', code: 'SYD', country: 'Australia', lat: -33.9399, lon: 151.1753 },
      { city: 'Tokyo', name: 'Haneda Airport', code: 'HND', country: 'Japan', lat: 35.5494, lon: 139.7798 },
      { city: 'Seoul', name: 'Incheon International', code: 'ICN', country: 'South Korea', lat: 37.4602, lon: 126.4407 },
      { city: 'Beijing', name: 'Beijing Capital', code: 'PEK', country: 'China', lat: 40.0799, lon: 116.6031 },
      { city: 'Shanghai', name: 'Shanghai Pudong', code: 'PVG', country: 'China', lat: 31.1434, lon: 121.8052 },
      { city: 'Hong Kong', name: 'Hong Kong International', code: 'HKG', country: 'China', lat: 22.308, lon: 113.9185 },
      { city: 'Bangkok', name: 'Suvarnabhumi', code: 'BKK', country: 'Thailand', lat: 13.690, lon: 100.75 },
      { city: 'Singapore', name: 'Changi Airport', code: 'SIN', country: 'Singapore', lat: 1.3644, lon: 103.9915 },
      { city: 'Delhi', name: 'Indira Gandhi', code: 'DEL', country: 'India', lat: 28.5562, lon: 77.1000 },
      { city: 'Dubai', name: 'Dubai International', code: 'DXB', country: 'UAE', lat: 25.2532, lon: 55.3657 },
      { city: 'Istanbul', name: 'Istanbul Airport', code: 'IST', country: 'Turkey', lat: 41.262, lon: 28.727 },
      { city: 'Athens', name: 'Athens International', code: 'ATH', country: 'Greece', lat: 37.9364, lon: 23.9445 },
      { city: 'Cairo', name: 'Cairo International', code: 'CAI', country: 'Egypt', lat: 30.112, lon: 31.414 },
      { city: 'Moscow', name: 'Sheremetyevo', code: 'SVO', country: 'Russia', lat: 55.9726, lon: 37.4146 },
      { city: 'Nairobi', name: 'Jomo Kenyatta', code: 'NBO', country: 'Kenya', lat: -1.3192, lon: 36.9278 },
      { city: 'Johannesburg', name: 'OR Tambo', code: 'JNB', country: 'South Africa', lat: -26.1337, lon: 28.2420 },
      { city: 'Paris', name: 'Charles de Gaulle', code: 'CDG', country: 'France', lat: 49.0097, lon: 2.5479 },
      { city: 'Frankfurt', name: 'Frankfurt Airport', code: 'FRA', country: 'Germany', lat: 50.0379, lon: 8.5622 },
      { city: 'London', name: 'Heathrow Airport', code: 'LHR', country: 'United Kingdom', lat: 51.4700, lon: -0.4543 },
      { city: 'Lagos', name: 'Murtala Muhammed', code: 'LOS', country: 'Nigeria', lat: 6.5774, lon: 3.3211 },
      { city: 'Reykjavík', name: 'Keflavík', code: 'KEF', country: 'Iceland', lat: 63.985, lon: -22.6056 },
      { city: 'New York', name: 'John F. Kennedy', code: 'JFK', country: 'USA', lat: 40.6413, lon: -73.7781 },
      { city: 'Washington D.C.', name: 'Dulles', code: 'IAD', country: 'USA', lat: 38.9531, lon: -77.4565 },
      { city: 'Atlanta', name: 'Hartsfield–Jackson', code: 'ATL', country: 'USA', lat: 33.6407, lon: -84.4277 },
      { city: 'Chicago', name: "O'Hare", code: 'ORD', country: 'USA', lat: 41.9742, lon: -87.9073 },
      { city: 'Denver', name: 'Denver International', code: 'DEN', country: 'USA', lat: 39.8561, lon: -104.6737 },
      { city: 'Dallas', name: 'DFW Airport', code: 'DFW', country: 'USA', lat: 32.8998, lon: -97.0403 },
      { city: 'Los Angeles', name: 'LAX', code: 'LAX', country: 'USA', lat: 33.9416, lon: -118.4085 },
      { city: 'San Francisco', name: 'San Francisco', code: 'SFO', country: 'USA', lat: 37.6213, lon: -122.3790 },
      { city: 'Seattle', name: 'Seattle–Tacoma', code: 'SEA', country: 'USA', lat: 47.4502, lon: -122.3088 },
      { city: 'Mexico City', name: 'Benito Juárez', code: 'MEX', country: 'Mexico', lat: 19.4361, lon: -99.0719 },
      { city: 'Toronto', name: 'Toronto Pearson', code: 'YYZ', country: 'Canada', lat: 43.6777, lon: -79.6248 },
      { city: 'Vancouver', name: 'Vancouver International', code: 'YVR', country: 'Canada', lat: 49.1967, lon: -123.1815 },
      { city: 'Anchorage', name: 'Ted Stevens Anchorage', code: 'ANC', country: 'USA', lat: 61.1743, lon: -149.9985 },
      { city: 'Honolulu', name: 'Honolulu International', code: 'HNL', country: 'USA', lat: 21.3187, lon: -157.9225 },
      { city: 'Buenos Aires', name: 'Ezeiza', code: 'EZE', country: 'Argentina', lat: -34.8222, lon: -58.5358 },
      { city: 'São Paulo', name: 'Guarulhos', code: 'GRU', country: 'Brazil', lat: -23.4356, lon: -46.4731 },
      { city: 'Santiago', name: 'Arturo Merino Benítez', code: 'SCL', country: 'Chile', lat: -33.3929, lon: -70.7858 },
      { city: 'Lima', name: 'Jorge Chávez', code: 'LIM', country: 'Peru', lat: -12.0219, lon: -77.1143 },
      { city: 'Bogotá', name: 'El Dorado', code: 'BOG', country: 'Colombia', lat: 4.7016, lon: -74.1469 },
      { city: 'Panama City', name: 'Tocumen', code: 'PTY', country: 'Panama', lat: 9.0714, lon: -79.3835 },
      { city: 'Madrid', name: 'Madrid-Barajas', code: 'MAD', country: 'Spain', lat: 40.4983, lon: -3.5676 },
      { city: 'Lisbon', name: 'Lisbon Portela', code: 'LIS', country: 'Portugal', lat: 38.7742, lon: -9.1342 },
      { city: 'Riyadh', name: 'King Khalid', code: 'RUH', country: 'Saudi Arabia', lat: 24.9576, lon: 46.6988 },
      { city: 'Karachi', name: 'Jinnah International', code: 'KHI', country: 'Pakistan', lat: 24.9065, lon: 67.1608 },
      { city: 'Kuala Lumpur', name: 'KLIA', code: 'KUL', country: 'Malaysia', lat: 2.7456, lon: 101.7072 },
      { city: 'Jakarta', name: 'Soekarno–Hatta', code: 'CGK', country: 'Indonesia', lat: -6.1256, lon: 106.6559 },
      { city: 'Manila', name: 'Ninoy Aquino', code: 'MNL', country: 'Philippines', lat: 14.5086, lon: 121.0198 },
      { city: 'Warsaw', name: 'Chopin Airport', code: 'WAW', country: 'Poland', lat: 52.1657, lon: 20.9671 },
      { city: 'Zurich', name: 'Zurich Airport', code: 'ZRH', country: 'Switzerland', lat: 47.4581, lon: 8.5555 },
      { city: 'Rome', name: 'Fiumicino', code: 'FCO', country: 'Italy', lat: 41.8003, lon: 12.2389 },
      { city: 'Stockholm', name: 'Arlanda', code: 'ARN', country: 'Sweden', lat: 59.6519, lon: 17.9186 },
      { city: 'Oslo', name: 'Gardermoen', code: 'OSL', country: 'Norway', lat: 60.1939, lon: 11.1004 },
      { city: 'Helsinki', name: 'Helsinki Airport', code: 'HEL', country: 'Finland', lat: 60.3172, lon: 24.9633 },
      { city: 'Doha', name: 'Hamad International', code: 'DOH', country: 'Qatar', lat: 25.2731, lon: 51.6081 },
      { city: 'Tehran', name: 'Imam Khomeini', code: 'IKA', country: 'Iran', lat: 35.4161, lon: 51.1522 },
      { city: 'Casablanca', name: 'Mohammed V', code: 'CMN', country: 'Morocco', lat: 33.3675, lon: -7.58997 },
      { city: 'Montreal', name: 'Montréal-Trudeau', code: 'YUL', country: 'Canada', lat: 45.4706, lon: -73.7408 },
      { city: 'Boston', name: 'Logan International', code: 'BOS', country: 'USA', lat: 42.3656, lon: -71.0096 }
    ];

    const timezoneCities = [
      { code: 'PPG', label: 'UTC-11 Pago Pago', lat: -14.331, lon: -170.713, type: 'timezone' },
      { code: 'HNL', label: 'UTC-10 Honolulu', lat: 21.3187, lon: -157.9225, type: 'timezone' },
      { code: 'ANC', label: 'UTC-09 Anchorage', lat: 61.1743, lon: -149.9985, type: 'timezone' },
      { code: 'LAX', label: 'UTC-08 Los Angeles', lat: 33.9416, lon: -118.4085, type: 'timezone' },
      { code: 'DEN', label: 'UTC-07 Denver', lat: 39.8561, lon: -104.6737, type: 'timezone' },
      { code: 'MEX', label: 'UTC-06 Mexico City', lat: 19.4361, lon: -99.0719, type: 'timezone' },
      { code: 'JFK', label: 'UTC-05 New York', lat: 40.6413, lon: -73.7781, type: 'timezone' },
      { code: 'SCL', label: 'UTC-04 Santiago', lat: -33.3929, lon: -70.7858, type: 'timezone' },
      { code: 'GRU', label: 'UTC-03 São Paulo', lat: -23.4356, lon: -46.4731, type: 'timezone' },
      { code: 'FEN', label: 'UTC-02 Noronha', lat: -3.854, lon: -32.423, type: 'timezone' },
      { code: 'PDL', label: 'UTC-01 Ponta Delgada', lat: 37.7412, lon: -25.6979, type: 'timezone' },
      { code: 'LHR', label: 'UTC+00 London', lat: 51.47, lon: -0.4543, type: 'timezone' },
      { code: 'FRA', label: 'UTC+01 Frankfurt', lat: 50.0379, lon: 8.5622, type: 'timezone' },
      { code: 'CAI', label: 'UTC+02 Cairo', lat: 30.112, lon: 31.414, type: 'timezone' },
      { code: 'IST', label: 'UTC+03 Istanbul', lat: 41.262, lon: 28.727, type: 'timezone' },
      { code: 'DXB', label: 'UTC+04 Dubai', lat: 25.2532, lon: 55.3657, type: 'timezone' },
      { code: 'KHI', label: 'UTC+05 Karachi', lat: 24.9065, lon: 67.1608, type: 'timezone' },
      { code: 'DEL', label: 'UTC+05:30 Delhi', lat: 28.5562, lon: 77.1, type: 'timezone' },
      { code: 'DAC', label: 'UTC+06 Dhaka', lat: 23.8433, lon: 90.3978, type: 'timezone' },
      { code: 'BKK', label: 'UTC+07 Bangkok', lat: 13.69, lon: 100.75, type: 'timezone' },
      { code: 'SIN', label: 'UTC+08 Singapore', lat: 1.3644, lon: 103.9915, type: 'timezone' },
      { code: 'TYO', label: 'UTC+09 Tokyo', lat: 35.5494, lon: 139.7798, type: 'timezone' },
      { code: 'SYD', label: 'UTC+10 Sydney', lat: -33.9399, lon: 151.1753, type: 'timezone' },
      { code: 'NOU', label: 'UTC+11 Nouméa', lat: -22.0146, lon: 166.2127, type: 'timezone' },
      { code: 'AKL', label: 'UTC+12 Auckland', lat: -37.0082, lon: 174.785, type: 'timezone' }
    ];

    const container = document.getElementById('globeContainer');
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    container.appendChild(canvas);

    const mapCanvas = document.createElement('canvas');
    const mapCtx = mapCanvas.getContext('2d');

    let mapReady = false;
    let mapPixels;

    const degToRad = (deg) => (deg * Math.PI) / 180;

    const state = {
      yaw: 0,
      pitch: -0.2,
      dragging: false,
      lastX: 0,
      lastY: 0,
      flightPath: null,
      markers: [],
      lastTimestamp: 0
    };

    function lonLatToPixel(lon, lat) {
      const x = ((lon + 180) / 360) * mapCanvas.width;
      const y = ((90 - lat) / 180) * mapCanvas.height;
      return { x, y };
    }

    function buildProceduralMap() {
      mapCanvas.width = 1600;
      mapCanvas.height = 800;

      const oceanGradient = mapCtx.createLinearGradient(0, 0, 0, mapCanvas.height);
      oceanGradient.addColorStop(0, '#82c8ff');
      oceanGradient.addColorStop(0.45, '#4ea3e6');
      oceanGradient.addColorStop(1, '#1f5ca8');
      mapCtx.fillStyle = oceanGradient;
      mapCtx.fillRect(0, 0, mapCanvas.width, mapCanvas.height);

      const landPolygons = [
        [
          [-168, 12],
          [-162, 55],
          [-150, 68],
          [-125, 72],
          [-100, 78],
          [-75, 76],
          [-58, 62],
          [-66, 46],
          [-90, 28],
          [-108, 12]
        ],
        [
          [-82, 12],
          [-74, -5],
          [-68, -12],
          [-66, -22],
          [-63, -35],
          [-50, -55],
          [-40, -55],
          [-34, -32],
          [-60, -8]
        ],
        [
          [-25, 35],
          [0, 70],
          [36, 75],
          [80, 70],
          [120, 60],
          [140, 55],
          [152, 48],
          [165, 55],
          [170, 48],
          [140, 36],
          [108, 18],
          [95, 6],
          [60, -8],
          [38, -8],
          [26, 4],
          [16, 24],
          [6, 34]
        ],
        [
          [10, 35],
          [24, 34],
          [32, 26],
          [36, 12],
          [32, -12],
          [20, -34],
          [10, -28],
          [4, -16],
          [-10, -34],
          [-22, -22],
          [-14, 10],
          [-4, 28]
        ],
        [
          [110, -10],
          [118, -16],
          [138, -10],
          [150, -24],
          [150, -36],
          [136, -46],
          [120, -40],
          [110, -30]
        ],
        [
          [-60, 60],
          [-40, 82],
          [-18, 76],
          [-26, 60]
        ],
        [
          [-180, -70],
          [-120, -78],
          [-60, -82],
          [0, -84],
          [60, -80],
          [120, -82],
          [180, -72]
        ]
      ];

      const seededNoise = (x, y, seed = 1337) => {
        const s = Math.sin(x * 127.1 + y * 311.7 + seed) * 43758.5453;
        return s - Math.floor(s);
      };

      const smoothNoise = (x, y) => {
        const xi = Math.floor(x);
        const yi = Math.floor(y);
        const xf = x - xi;
        const yf = y - yi;

        const v00 = seededNoise(xi, yi);
        const v10 = seededNoise(xi + 1, yi);
        const v01 = seededNoise(xi, yi + 1);
        const v11 = seededNoise(xi + 1, yi + 1);

        const i1 = v00 + (v10 - v00) * xf;
        const i2 = v01 + (v11 - v01) * xf;
        return i1 + (i2 - i1) * yf;
      };

      const fbm = (x, y) => {
        let value = 0;
        let amplitude = 0.55;
        let frequency = 1.1;
        for (let i = 0; i < 4; i++) {
          value += smoothNoise(x * frequency, y * frequency) * amplitude;
          amplitude *= 0.55;
          frequency *= 2.15;
        }
        return value;
      };

      const landFill = mapCtx.createLinearGradient(0, 0, mapCanvas.width, mapCanvas.height);
      landFill.addColorStop(0, '#5fa56b');
      landFill.addColorStop(0.5, '#6fbb7c');
      landFill.addColorStop(1, '#78c185');
      mapCtx.lineWidth = 1;
      mapCtx.strokeStyle = 'rgba(255, 255, 255, 0.06)';

      landPolygons.forEach((polygon) => {
        mapCtx.beginPath();
        polygon.forEach(([lon, lat], idx) => {
          const { x, y } = lonLatToPixel(lon, lat);
          if (idx === 0) mapCtx.moveTo(x, y);
          else mapCtx.lineTo(x, y);
        });
        mapCtx.closePath();
        mapCtx.fillStyle = landFill;
        mapCtx.fill();
        mapCtx.stroke();
      });

      const landMask = mapCtx.getImageData(0, 0, mapCanvas.width, mapCanvas.height);

      for (let y = 0; y < mapCanvas.height; y++) {
        for (let x = 0; x < mapCanvas.width; x++) {
          const idx = (y * mapCanvas.width + x) * 4;
          const alpha = landMask.data[idx + 3] / 255;
          const lat = 90 - (y / mapCanvas.height) * 180;
          const lon = (x / mapCanvas.width) * 360 - 180;

          if (alpha === 0) {
            const depthNoise = fbm(x * 0.003, y * 0.003);
            const shelf = Math.max(0, 1 - Math.abs(depthNoise * 0.8));
            const base = 110 + shelf * 60;
            const deep = 160 + shelf * 65;
            landMask.data[idx] = 32 + shelf * 15;
            landMask.data[idx + 1] = base;
            landMask.data[idx + 2] = deep;
            landMask.data[idx + 3] = 255;
            continue;
          }

          const terrain = fbm(x * 0.005, y * 0.005);
          const ridge = fbm(x * 0.01 + 40, y * 0.01 - 20);
          const elevation = Math.min(1, Math.max(0, terrain * 0.65 + ridge * 0.35));
          const dryness = Math.pow(Math.abs(lat) / 90, 1.2);
          const equatorBoost = Math.max(0, 1 - Math.abs(lat) / 75);
          const iceInfluence = Math.max(0, (Math.abs(lat) - 60) / 30);

          const forestColor = [86, 158, 92];
          const desertColor = [216, 196, 150];
          const alpineColor = [238, 244, 249];
          const tundraColor = [210, 222, 228];

          const mix = Math.min(1, dryness * 0.75 + (1 - equatorBoost) * 0.25);
          let r = forestColor[0] * (1 - mix) + desertColor[0] * mix;
          let g = forestColor[1] * (1 - mix) + desertColor[1] * mix;
          let b = forestColor[2] * (1 - mix) + desertColor[2] * mix;

          const alpine = Math.max(0, elevation - 0.55) * 1.25;
          const ice = Math.min(1, iceInfluence * 1.2);
          r = r * (1 - alpine) + alpineColor[0] * alpine;
          g = g * (1 - alpine) + alpineColor[1] * alpine;
          b = b * (1 - alpine) + alpineColor[2] * alpine;

          r = r * (1 - ice) + tundraColor[0] * ice;
          g = g * (1 - ice) + tundraColor[1] * ice;
          b = b * (1 - ice) + tundraColor[2] * ice;

          const shade = 1 + elevation * 0.18 + fbm(x * 0.02, y * 0.02) * 0.06;
          landMask.data[idx] = Math.min(255, r * shade);
          landMask.data[idx + 1] = Math.min(255, g * shade);
          landMask.data[idx + 2] = Math.min(255, b * shade);
          landMask.data[idx + 3] = 255;
        }
      }

      mapCtx.putImageData(landMask, 0, 0);

      for (let i = 0; i < 1200; i++) {
        const x = Math.random() * mapCanvas.width;
        const y = Math.random() * mapCanvas.height;
        const r = Math.random() * 1.4 + 0.4;
        mapCtx.fillStyle = 'rgba(255, 255, 255, 0.012)';
        mapCtx.beginPath();
        mapCtx.arc(x, y, r, 0, Math.PI * 2);
        mapCtx.fill();
      }

      mapPixels = mapCtx.getImageData(0, 0, mapCanvas.width, mapCanvas.height).data;
      mapReady = true;
    }

    buildProceduralMap();

    const normalizedTimezoneCities = timezoneCities.map((city) => ({ ...city, lng: city.lon ?? city.lng }));
    state.markers = [...normalizedTimezoneCities];

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }

    window.addEventListener('resize', resize);

    function latLonToVector(lat, lon) {
      const phi = degToRad(90 - lat);
      const theta = degToRad(lon + 180);
      return {
        x: Math.sin(phi) * Math.cos(theta),
        y: Math.cos(phi),
        z: Math.sin(phi) * Math.sin(theta)
      };
    }

    function rotateVector(vec) {
      const cosYaw = Math.cos(state.yaw);
      const sinYaw = Math.sin(state.yaw);
      const cosPitch = Math.cos(state.pitch);
      const sinPitch = Math.sin(state.pitch);

      const xzRotatedX = vec.x * cosYaw - vec.z * sinYaw;
      const xzRotatedZ = vec.x * sinYaw + vec.z * cosYaw;

      const yRotatedY = vec.y * cosPitch - xzRotatedZ * sinPitch;
      const yRotatedZ = vec.y * sinPitch + xzRotatedZ * cosPitch;

      return { x: xzRotatedX, y: yRotatedY, z: yRotatedZ };
    }

    function getSunPosition(date = new Date()) {
      const rad = Math.PI / 180;
      const JD = date.getTime() / 86400000 + 2440587.5;
      const d = JD - 2451545.0;
      const g = (357.529 + 0.98560028 * d) % 360;
      const q = (280.459 + 0.98564736 * d) % 360;
      const L = (q + 1.915 * Math.sin(g * rad) + 0.020 * Math.sin(2 * g * rad)) % 360;
      const e = 23.439 - 0.00000036 * d;
      const RA = Math.atan2(Math.cos(e * rad) * Math.sin(L * rad), Math.cos(L * rad));
      const decl = Math.asin(Math.sin(e * rad) * Math.sin(L * rad));
      const RAdeg = RA / rad;
      const GMST = (18.697374558 + 24.06570982441908 * d) % 24;
      const GMSTdeg = GMST * 15;
      const subLon = ((RAdeg - GMSTdeg + 540) % 360) - 180;
      const subLat = decl / rad;
      return { lat: subLat, lon: subLon };
    }

    function sampleMapColor(lat, lon) {
      if (!mapReady) return null;
      const u = ((lon + 180) / 360) * mapCanvas.width;
      const v = ((90 - lat) / 180) * mapCanvas.height;
      const x = Math.min(mapCanvas.width - 1, Math.max(0, Math.floor(u)));
      const y = Math.min(mapCanvas.height - 1, Math.max(0, Math.floor(v)));
      const idx = (y * mapCanvas.width + x) * 4;
      return [mapPixels[idx], mapPixels[idx + 1], mapPixels[idx + 2], mapPixels[idx + 3] / 255];
    }

    function project(vector) {
      const rotated = rotateVector(vector);
      const radius = Math.min(canvas.width, canvas.height) * 0.36;
      const cx = canvas.width / 2;
      const cy = canvas.height / 2;
      const x = cx + rotated.x * radius;
      const y = cy - rotated.y * radius;
      return { x, y, z: rotated.z, visible: rotated.z > 0 };
    }

    function drawGlobeBase() {
      const radius = Math.min(canvas.width, canvas.height) * 0.36;
      const cx = canvas.width / 2;
      const cy = canvas.height / 2;

      ctx.save();
      ctx.fillStyle = '#05070e';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      const glow = ctx.createRadialGradient(cx - radius * 0.35, cy - radius * 0.35, radius * 0.4, cx, cy, radius * 1.1);
      glow.addColorStop(0, '#13233d');
      glow.addColorStop(0.45, '#0c162a');
      glow.addColorStop(1, '#050912');

      ctx.beginPath();
      ctx.arc(cx, cy, radius, 0, Math.PI * 2);
      ctx.fillStyle = glow;
      ctx.fill();

      const rim = ctx.createRadialGradient(cx, cy, radius * 0.6, cx, cy, radius * 1.03);
      rim.addColorStop(0, 'rgba(0, 224, 255, 0)');
      rim.addColorStop(0.8, 'rgba(0, 224, 255, 0.24)');
      rim.addColorStop(1, 'rgba(0, 224, 255, 0.4)');

      ctx.beginPath();
      ctx.arc(cx, cy, radius, 0, Math.PI * 2);
      ctx.strokeStyle = 'rgba(0, 224, 255, 0.35)';
      ctx.lineWidth = 1.5;
      ctx.stroke();

      ctx.globalCompositeOperation = 'lighter';
      ctx.fillStyle = rim;
      ctx.beginPath();
      ctx.arc(cx, cy, radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalCompositeOperation = 'source-over';

      ctx.restore();
    }

    function drawEarthTexture() {
      if (!mapReady) return;

      const sun = getSunPosition();
      const sunVec = latLonToVector(sun.lat, sun.lon);
      const cellSize = Math.max(1, Math.min(canvas.width, canvas.height) * 0.0048);

      ctx.save();
      for (let lat = -90; lat <= 90; lat += 2) {
        for (let lon = -180; lon < 180; lon += 2) {
          const vec = latLonToVector(lat, lon);
          const p = project(vec);
          if (!p.visible) continue;

          const color = sampleMapColor(lat, lon);
          if (!color) continue;

          const light = vec.x * sunVec.x + vec.y * sunVec.y + vec.z * sunVec.z;
          const diffuse = Math.max(0, light);
          const night = Math.max(0, -light);
          const twilight = Math.max(0, 1 - Math.abs(light * 4));
          const ambient = 0.32;
          const nightVisibility = 0.42;

          const brightness = ambient + diffuse * 1.3;
          const visibility = nightVisibility + (1 - nightVisibility) * Math.max(0, light * 0.72 + 0.45);
          const rimLight = Math.pow(Math.max(0, light), 3.6) * 0.48;
          const nightTint = night * 0.2;

          const r = Math.min(
            255,
            color[0] * brightness * visibility + 32 * twilight + 14 * nightTint + rimLight * 155
          );
          const g = Math.min(
            255,
            color[1] * brightness * visibility + 28 * twilight + 18 * nightTint + rimLight * 145
          );
          const b = Math.min(
            255,
            color[2] * brightness * visibility + 36 * twilight + 28 * nightTint + rimLight * 180
          );

          ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${color[3]})`;
          ctx.beginPath();
          ctx.arc(p.x, p.y, cellSize * 0.5, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      ctx.restore();
    }

    function drawGraticule() {
      const radius = Math.min(canvas.width, canvas.height) * 0.36;
      const cx = canvas.width / 2;
      const cy = canvas.height / 2;
      ctx.save();
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
      ctx.lineWidth = 1;

      for (let lat = -60; lat <= 60; lat += 30) {
        ctx.beginPath();
        let started = false;
        for (let lon = -180; lon <= 180; lon += 5) {
          const vec = latLonToVector(lat, lon);
          const p = project(vec);
          if (!p.visible) {
            started = false;
            continue;
          }
          if (!started) {
            ctx.moveTo(p.x, p.y);
            started = true;
          } else {
            ctx.lineTo(p.x, p.y);
          }
        }
        ctx.stroke();
      }

      for (let lon = -150; lon <= 150; lon += 30) {
        ctx.beginPath();
        let started = false;
        for (let lat = -90; lat <= 90; lat += 5) {
          const vec = latLonToVector(lat, lon);
          const p = project(vec);
          if (!p.visible) {
            started = false;
            continue;
          }
          if (!started) {
            ctx.moveTo(p.x, p.y);
            started = true;
          } else {
            ctx.lineTo(p.x, p.y);
          }
        }
        ctx.stroke();
      }

      ctx.restore();
    }

    function drawMarkers() {
      state.markers.forEach((marker) => {
        const vec = latLonToVector(marker.lat, marker.lng ?? marker.lon);
        const projected = project(vec);
        if (!projected.visible) return;

        const size = marker.type === 'airport' ? 6 : 4;
        ctx.save();
        ctx.beginPath();
        ctx.fillStyle = marker.type === 'airport' ? '#7ae1ff' : '#ffd166';
        ctx.shadowColor = marker.type === 'airport' ? 'rgba(122, 225, 255, 0.8)' : 'rgba(255, 209, 102, 0.6)';
        ctx.shadowBlur = 8;
        ctx.arc(projected.x, projected.y, size, 0, Math.PI * 2);
        ctx.fill();

        const label = marker.label ?? marker.code ?? '';
        if (label) {
          ctx.font = '12px Inter, system-ui, sans-serif';
          ctx.shadowBlur = 0;
          ctx.fillStyle = 'rgba(0, 0, 0, 0.55)';
          const textWidth = ctx.measureText(label).width;
          ctx.fillRect(projected.x + size + 4, projected.y - 11, textWidth + 10, 18);
          ctx.fillStyle = marker.type === 'airport' ? '#c6f6ff' : '#fff7d6';
          ctx.fillText(label, projected.x + size + 9, projected.y + 2);
        }
        ctx.restore();
      });
    }

    function greatCircleDistance(a, b) {
      const R = 6371;
      const dLat = degToRad(b.lat - a.lat);
      const dLon = degToRad(b.lon - a.lon);
      const lat1 = degToRad(a.lat);
      const lat2 = degToRad(b.lat);
      const h = Math.sin(dLat / 2) ** 2 + Math.cos(lat1) * Math.cos(lat2) * Math.sin(dLon / 2) ** 2;
      return 2 * R * Math.asin(Math.min(1, Math.sqrt(h)));
    }

    function computeArcPoints(from, to) {
      const start = latLonToVector(from.lat, from.lon ?? from.lng);
      const end = latLonToVector(to.lat, to.lon ?? to.lng);

      const startLen = Math.hypot(start.x, start.y, start.z);
      const endLen = Math.hypot(end.x, end.y, end.z);
      const startNorm = { x: start.x / startLen, y: start.y / startLen, z: start.z / startLen };
      const endNorm = { x: end.x / endLen, y: end.y / endLen, z: end.z / endLen };

      const dot = Math.min(1, Math.max(-1, startNorm.x * endNorm.x + startNorm.y * endNorm.y + startNorm.z * endNorm.z));
      const angle = Math.acos(dot);
      const steps = 120;
      const distance = greatCircleDistance(from, to);
      const points = [];

      for (let i = 0; i <= steps; i++) {
        const t = i / steps;
        const sinTotal = Math.sin(angle) || 1;
        const A = Math.sin((1 - t) * angle) / sinTotal;
        const B = Math.sin(t * angle) / sinTotal;
        const x = A * startNorm.x + B * endNorm.x;
        const y = A * startNorm.y + B * endNorm.y;
        const z = A * startNorm.z + B * endNorm.z;
        const length = Math.hypot(x, y, z) || 1;
        points.push({ x: x / length, y: y / length, z: z / length });
      }
      return { points, distance };
    }

    function focusOnVector(vec) {
      const yaw = Math.atan2(vec.x, vec.z);
      const zPrime = vec.x * Math.sin(yaw) + vec.z * Math.cos(yaw);
      const pitch = Math.atan2(vec.y, zPrime);
      state.yaw = yaw;
      state.pitch = pitch;
    }

    function drawFlightPath() {
      if (!state.flightPath) return;
      const { points } = state.flightPath;
      ctx.save();
      ctx.lineWidth = 2.5;
      ctx.strokeStyle = 'rgba(0, 224, 255, 0.9)';
      ctx.shadowColor = 'rgba(0, 224, 255, 0.55)';
      ctx.shadowBlur = 10;

      let started = false;
      ctx.beginPath();
      points.forEach((vec) => {
        const projected = project(vec);
        if (!projected.visible) {
          started = false;
          return;
        }
        if (!started) {
          ctx.moveTo(projected.x, projected.y);
          started = true;
        } else {
          ctx.lineTo(projected.x, projected.y);
        }
      });
      ctx.stroke();
      ctx.restore();
    }

    function drawScene(timestamp = 0) {
      const delta = state.lastTimestamp ? timestamp - state.lastTimestamp : 16;
      state.lastTimestamp = timestamp;
      if (!state.dragging) {
        state.yaw += delta * 0.00025;
      }

      drawGlobeBase();
      drawEarthTexture();
      drawGraticule();
      drawFlightPath();
      drawMarkers();

      requestAnimationFrame(drawScene);
    }

    canvas.addEventListener('pointerdown', (e) => {
      state.dragging = true;
      state.lastX = e.clientX;
      state.lastY = e.clientY;
      canvas.setPointerCapture(e.pointerId);
    });

    canvas.addEventListener('pointermove', (e) => {
      if (!state.dragging) return;
      const dx = e.clientX - state.lastX;
      const dy = e.clientY - state.lastY;
      state.yaw += dx * 0.005;
      state.pitch += dy * 0.005;
      state.pitch = Math.max(Math.min(state.pitch, Math.PI / 2 - 0.1), -Math.PI / 2 + 0.1);
      state.lastX = e.clientX;
      state.lastY = e.clientY;
    });

    canvas.addEventListener('pointerup', (e) => {
      state.dragging = false;
      canvas.releasePointerCapture(e.pointerId);
    });

    function populateAirportList() {
      const list = document.getElementById('airportOptions');
      list.innerHTML = '';
      airportData.forEach((apt) => {
        const opt = document.createElement('option');
        opt.value = apt.code;
        opt.label = `${apt.name} — ${apt.city}, ${apt.country}`;
        list.appendChild(opt);
      });
    }

    function findAirport(query) {
      const normalized = query.trim().toLowerCase();
      if (!normalized) return undefined;
      const codeCandidate = normalized.split(/[—-]/)[0].trim();
      return airportData.find((apt) =>
        apt.code.toLowerCase() === normalized ||
        apt.code.toLowerCase() === codeCandidate ||
        apt.name.toLowerCase().includes(normalized) ||
        apt.city.toLowerCase().includes(normalized)
      );
    }

    function setFlightPath(from, to) {
      const fromPoint = { ...from, lng: from.lon ?? from.lng, type: 'airport', label: from.code };
      const toPoint = { ...to, lng: to.lon ?? to.lng, type: 'airport', label: to.code };
      const { points, distance } = computeArcPoints(from, to);
      state.flightPath = { points, distance };
      state.markers = [...normalizedTimezoneCities, fromPoint, toPoint];
      if (points.length) {
        focusOnVector(points[Math.floor(points.length / 2)]);
      }
    }

    function clearFlightPath() {
      state.flightPath = null;
      state.markers = [...normalizedTimezoneCities];
    }

    function handleFlightRequest() {
      const fromInput = document.getElementById('fromInput').value;
      const toInput = document.getElementById('toInput').value;
      const errorEl = document.getElementById('error');
      errorEl.textContent = '';

      const from = findAirport(fromInput);
      const to = findAirport(toInput);

      if (!from || !to) {
        errorEl.textContent = 'Please choose airports from the list or enter a known IATA code.';
        clearFlightPath();
        return;
      }
      if (from.code === to.code) {
        errorEl.textContent = 'Pick two different airports to draw a route.';
        clearFlightPath();
        return;
      }

      setFlightPath(from, to);
      errorEl.textContent = `${from.city} (${from.code}) → ${to.city} (${to.code}) shown. Touch or drag to explore the route.`;
    }

    document.getElementById('plotBtn').addEventListener('click', handleFlightRequest);
    document.getElementById('fromInput').addEventListener('keydown', (e) => {
      if (e.key === 'Enter') handleFlightRequest();
    });
    document.getElementById('toInput').addEventListener('keydown', (e) => {
      if (e.key === 'Enter') handleFlightRequest();
    });

    populateAirportList();
    resize();
    requestAnimationFrame(drawScene);
  </script>
</body>
</html>
